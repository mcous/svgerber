!function a(b,c,d){function e(g,h){if(!c[g]){if(!b[g]){var i="function"==typeof require&&require;if(!h&&i)return i(g,!0);if(f)return f(g,!0);var j=new Error("Cannot find module '"+g+"'");throw j.code="MODULE_NOT_FOUND",j}var k=c[g]={exports:{}};b[g][0].call(k.exports,function(a){var c=b[g][1][a];return e(c?c:a)},k,k.exports,a,b,c,d)}return c[g].exports}for(var f="function"==typeof require&&require,g=0;g<d.length;g++)e(d[g]);return e}({"./src/index.coffee":[function(a){var b,c,d,e,f,g;c=a("Base64"),"function"!=typeof window.btoa&&(window.btoa=c.btoa),"function"!=typeof window.atob&&(window.atob=c.atob),("undefined"==typeof document.createElement("svg").getAttributeNS||"undefined"==typeof Worker)&&(g=new(a("./views/unsupported-view")),$("body").append(g.render().el)),b=a("./views/app-view"),e=new b,d=a("./routers/router"),f=new d,Backbone.history.start()},{"./routers/router":"/Users/mc/projects/svgerber/src/routers/router.coffee","./views/app-view":"/Users/mc/projects/svgerber/src/views/app-view.coffee","./views/unsupported-view":"/Users/mc/projects/svgerber/src/views/unsupported-view.coffee",Base64:"/Users/mc/projects/svgerber/node_modules/Base64/base64.js"}],"/Users/mc/projects/svgerber/node_modules/Base64/base64.js":[function(a,b,c){!function(){function a(a){this.message=a}var b="undefined"!=typeof c?c:this,d="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";a.prototype=new Error,a.prototype.name="InvalidCharacterError",b.btoa||(b.btoa=function(b){for(var c,e,f=String(b),g=0,h=d,i="";f.charAt(0|g)||(h="=",g%1);i+=h.charAt(63&c>>8-g%1*8)){if(e=f.charCodeAt(g+=.75),e>255)throw new a("'btoa' failed: The string to be encoded contains characters outside of the Latin1 range.");c=c<<8|e}return i}),b.atob||(b.atob=function(b){var c=String(b).replace(/=+$/,"");if(c.length%4==1)throw new a("'atob' failed: The string to be decoded is not correctly encoded.");for(var e,f,g=0,h=0,i="";f=c.charAt(h++);~f&&(e=g%4?64*e+f:f,g++%4)?i+=String.fromCharCode(255&e>>(-2*g&6)):0)f=d.indexOf(f);return i})}()},{}],"/Users/mc/projects/svgerber/src/collections/boards.coffee":[function(a,b){var c,d,e,f,g={}.hasOwnProperty,h=function(a,b){function c(){this.constructor=a}for(var d in b)g.call(b,d)&&(a[d]=b[d]);return c.prototype=b.prototype,a.prototype=new c,a.__super__=b.prototype,a};e=a("./renders"),c=a("../models/board"),f=new Worker(window.URL.createObjectURL(new Blob(["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error(\"Cannot find module '\"+o+\"'\")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n/**\n * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>\n * Build: `lodash modularize modern exports=\"npm\" -o ./npm/`\n * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>\n * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>\n * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n * Available under MIT license <http://lodash.com/license>\n */\nvar createCallback = require('lodash.createcallback'),\n    forOwn = require('lodash.forown');\n\n/**\n * Iterates over elements of a collection, returning the first element that\n * the callback returns truey for. The callback is bound to `thisArg` and\n * invoked with three arguments; (value, index|key, collection).\n *\n * If a property name is provided for `callback` the created \"_.pluck\" style\n * callback will return the property value of the given element.\n *\n * If an object is provided for `callback` the created \"_.where\" style callback\n * will return `true` for elements that have the properties of the given object,\n * else `false`.\n *\n * @static\n * @memberOf _\n * @alias detect, findWhere\n * @category Collections\n * @param {Array|Object|string} collection The collection to iterate over.\n * @param {Function|Object|string} [callback=identity] The function called\n *  per iteration. If a property name or object is provided it will be used\n *  to create a \"_.pluck\" or \"_.where\" style callback, respectively.\n * @param {*} [thisArg] The `this` binding of `callback`.\n * @returns {*} Returns the found element, else `undefined`.\n * @example\n *\n * var characters = [\n *   { 'name': 'barney',  'age': 36, 'blocked': false },\n *   { 'name': 'fred',    'age': 40, 'blocked': true },\n *   { 'name': 'pebbles', 'age': 1,  'blocked': false }\n * ];\n *\n * _.find(characters, function(chr) {\n *   return chr.age < 40;\n * });\n * // => { 'name': 'barney', 'age': 36, 'blocked': false }\n *\n * // using \"_.where\" callback shorthand\n * _.find(characters, { 'age': 1 });\n * // =>  { 'name': 'pebbles', 'age': 1, 'blocked': false }\n *\n * // using \"_.pluck\" callback shorthand\n * _.find(characters, 'blocked');\n * // => { 'name': 'fred', 'age': 40, 'blocked': true }\n */\nfunction find(collection, callback, thisArg) {\n  callback = createCallback(callback, thisArg, 3);\n\n  var index = -1,\n      length = collection ? collection.length : 0;\n\n  if (typeof length == 'number') {\n    while (++index < length) {\n      var value = collection[index];\n      if (callback(value, index, collection)) {\n        return value;\n      }\n    }\n  } else {\n    var result;\n    forOwn(collection, function(value, index, collection) {\n      if (callback(value, index, collection)) {\n        result = value;\n        return false;\n      }\n    });\n    return result;\n  }\n}\n\nmodule.exports = find;\n\n},{\"lodash.createcallback\":2,\"lodash.forown\":38}],2:[function(require,module,exports){\n/**\n * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>\n * Build: `lodash modularize modern exports=\"npm\" -o ./npm/`\n * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>\n * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>\n * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n * Available under MIT license <http://lodash.com/license>\n */\nvar baseCreateCallback = require('lodash._basecreatecallback'),\n    baseIsEqual = require('lodash._baseisequal'),\n    isObject = require('lodash.isobject'),\n    keys = require('lodash.keys'),\n    property = require('lodash.property');\n\n/**\n * Produces a callback bound to an optional `thisArg`. If `func` is a property\n * name the created callback will return the property value for a given element.\n * If `func` is an object the created callback will return `true` for elements\n * that contain the equivalent object properties, otherwise it will return `false`.\n *\n * @static\n * @memberOf _\n * @category Utilities\n * @param {*} [func=identity] The value to convert to a callback.\n * @param {*} [thisArg] The `this` binding of the created callback.\n * @param {number} [argCount] The number of arguments the callback accepts.\n * @returns {Function} Returns a callback function.\n * @example\n *\n * var characters = [\n *   { 'name': 'barney', 'age': 36 },\n *   { 'name': 'fred',   'age': 40 }\n * ];\n *\n * // wrap to create custom callback shorthands\n * _.createCallback = _.wrap(_.createCallback, function(func, callback, thisArg) {\n *   var match = /^(.+?)__([gl]t)(.+)$/.exec(callback);\n *   return !match ? func(callback, thisArg) : function(object) {\n *     return match[2] == 'gt' ? object[match[1]] > match[3] : object[match[1]] < match[3];\n *   };\n * });\n *\n * _.filter(characters, 'age__gt38');\n * // => [{ 'name': 'fred', 'age': 40 }]\n */\nfunction createCallback(func, thisArg, argCount) {\n  var type = typeof func;\n  if (func == null || type == 'function') {\n    return baseCreateCallback(func, thisArg, argCount);\n  }\n  // handle \"_.pluck\" style callback shorthands\n  if (type != 'object') {\n    return property(func);\n  }\n  var props = keys(func),\n      key = props[0],\n      a = func[key];\n\n  // handle \"_.where\" style callback shorthands\n  if (props.length == 1 && a === a && !isObject(a)) {\n    // fast path the common case of providing an object with a single\n    // property containing a primitive value\n    return function(object) {\n      var b = object[key];\n      return a === b && (a !== 0 || (1 / a == 1 / b));\n    };\n  }\n  return function(object) {\n    var length = props.length,\n        result = false;\n\n    while (length--) {\n      if (!(result = baseIsEqual(object[props[length]], func[props[length]], null, true))) {\n        break;\n      }\n    }\n    return result;\n  };\n}\n\nmodule.exports = createCallback;\n\n},{\"lodash._basecreatecallback\":3,\"lodash._baseisequal\":22,\"lodash.isobject\":31,\"lodash.keys\":33,\"lodash.property\":37}],3:[function(require,module,exports){\n/**\n * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>\n * Build: `lodash modularize modern exports=\"npm\" -o ./npm/`\n * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>\n * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>\n * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n * Available under MIT license <http://lodash.com/license>\n */\nvar bind = require('lodash.bind'),\n    identity = require('lodash.identity'),\n    setBindData = require('lodash._setbinddata'),\n    support = require('lodash.support');\n\n/** Used to detected named functions */\nvar reFuncName = /^\\s*function[ \\n\\r\\t]+\\w/;\n\n/** Used to detect functions containing a `this` reference */\nvar reThis = /\\bthis\\b/;\n\n/** Native method shortcuts */\nvar fnToString = Function.prototype.toString;\n\n/**\n * The base implementation of `_.createCallback` without support for creating\n * \"_.pluck\" or \"_.where\" style callbacks.\n *\n * @private\n * @param {*} [func=identity] The value to convert to a callback.\n * @param {*} [thisArg] The `this` binding of the created callback.\n * @param {number} [argCount] The number of arguments the callback accepts.\n * @returns {Function} Returns a callback function.\n */\nfunction baseCreateCallback(func, thisArg, argCount) {\n  if (typeof func != 'function') {\n    return identity;\n  }\n  // exit early for no `thisArg` or already bound by `Function#bind`\n  if (typeof thisArg == 'undefined' || !('prototype' in func)) {\n    return func;\n  }\n  var bindData = func.__bindData__;\n  if (typeof bindData == 'undefined') {\n    if (support.funcNames) {\n      bindData = !func.name;\n    }\n    bindData = bindData || !support.funcDecomp;\n    if (!bindData) {\n      var source = fnToString.call(func);\n      if (!support.funcNames) {\n        bindData = !reFuncName.test(source);\n      }\n      if (!bindData) {\n        // checks if `func` references the `this` keyword and stores the result\n        bindData = reThis.test(source);\n        setBindData(func, bindData);\n      }\n    }\n  }\n  // exit early if there are no `this` references or `func` is bound\n  if (bindData === false || (bindData !== true && bindData[1] & 1)) {\n    return func;\n  }\n  switch (argCount) {\n    case 1: return function(value) {\n      return func.call(thisArg, value);\n    };\n    case 2: return function(a, b) {\n      return func.call(thisArg, a, b);\n    };\n    case 3: return function(value, index, collection) {\n      return func.call(thisArg, value, index, collection);\n    };\n    case 4: return function(accumulator, value, index, collection) {\n      return func.call(thisArg, accumulator, value, index, collection);\n    };\n  }\n  return bind(func, thisArg);\n}\n\nmodule.exports = baseCreateCallback;\n\n},{\"lodash._setbinddata\":4,\"lodash.bind\":7,\"lodash.identity\":19,\"lodash.support\":20}],4:[function(require,module,exports){\n/**\n * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>\n * Build: `lodash modularize modern exports=\"npm\" -o ./npm/`\n * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>\n * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>\n * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n * Available under MIT license <http://lodash.com/license>\n */\nvar isNative = require('lodash._isnative'),\n    noop = require('lodash.noop');\n\n/** Used as the property descriptor for `__bindData__` */\nvar descriptor = {\n  'configurable': false,\n  'enumerable': false,\n  'value': null,\n  'writable': false\n};\n\n/** Used to set meta data on functions */\nvar defineProperty = (function() {\n  // IE 8 only accepts DOM elements\n  try {\n    var o = {},\n        func = isNative(func = Object.defineProperty) && func,\n        result = func(o, o, o) && func;\n  } catch(e) { }\n  return result;\n}());\n\n/**\n * Sets `this` binding data on a given function.\n *\n * @private\n * @param {Function} func The function to set data on.\n * @param {Array} value The data array to set.\n */\nvar setBindData = !defineProperty ? noop : function(func, value) {\n  descriptor.value = value;\n  defineProperty(func, '__bindData__', descriptor);\n};\n\nmodule.exports = setBindData;\n\n},{\"lodash._isnative\":5,\"lodash.noop\":6}],5:[function(require,module,exports){\n/**\n * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>\n * Build: `lodash modularize modern exports=\"npm\" -o ./npm/`\n * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>\n * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>\n * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n * Available under MIT license <http://lodash.com/license>\n */\n\n/** Used for native method references */\nvar objectProto = Object.prototype;\n\n/** Used to resolve the internal [[Class]] of values */\nvar toString = objectProto.toString;\n\n/** Used to detect if a method is native */\nvar reNative = RegExp('^' +\n  String(toString)\n    .replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')\n    .replace(/toString| for [^\\]]+/g, '.*?') + '$'\n);\n\n/**\n * Checks if `value` is a native function.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if the `value` is a native function, else `false`.\n */\nfunction isNative(value) {\n  return typeof value == 'function' && reNative.test(value);\n}\n\nmodule.exports = isNative;\n\n},{}],6:[function(require,module,exports){\n/**\n * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>\n * Build: `lodash modularize modern exports=\"npm\" -o ./npm/`\n * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>\n * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>\n * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n * Available under MIT license <http://lodash.com/license>\n */\n\n/**\n * A no-operation function.\n *\n * @static\n * @memberOf _\n * @category Utilities\n * @example\n *\n * var object = { 'name': 'fred' };\n * _.noop(object) === undefined;\n * // => true\n */\nfunction noop() {\n  // no operation performed\n}\n\nmodule.exports = noop;\n\n},{}],7:[function(require,module,exports){\n/**\n * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>\n * Build: `lodash modularize modern exports=\"npm\" -o ./npm/`\n * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>\n * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>\n * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n * Available under MIT license <http://lodash.com/license>\n */\nvar createWrapper = require('lodash._createwrapper'),\n    slice = require('lodash._slice');\n\n/**\n * Creates a function that, when called, invokes `func` with the `this`\n * binding of `thisArg` and prepends any additional `bind` arguments to those\n * provided to the bound function.\n *\n * @static\n * @memberOf _\n * @category Functions\n * @param {Function} func The function to bind.\n * @param {*} [thisArg] The `this` binding of `func`.\n * @param {...*} [arg] Arguments to be partially applied.\n * @returns {Function} Returns the new bound function.\n * @example\n *\n * var func = function(greeting) {\n *   return greeting + ' ' + this.name;\n * };\n *\n * func = _.bind(func, { 'name': 'fred' }, 'hi');\n * func();\n * // => 'hi fred'\n */\nfunction bind(func, thisArg) {\n  return arguments.length > 2\n    ? createWrapper(func, 17, slice(arguments, 2), null, thisArg)\n    : createWrapper(func, 1, null, null, thisArg);\n}\n\nmodule.exports = bind;\n\n},{\"lodash._createwrapper\":8,\"lodash._slice\":18}],8:[function(require,module,exports){\n/**\n * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>\n * Build: `lodash modularize modern exports=\"npm\" -o ./npm/`\n * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>\n * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>\n * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n * Available under MIT license <http://lodash.com/license>\n */\nvar baseBind = require('lodash._basebind'),\n    baseCreateWrapper = require('lodash._basecreatewrapper'),\n    isFunction = require('lodash.isfunction'),\n    slice = require('lodash._slice');\n\n/**\n * Used for `Array` method references.\n *\n * Normally `Array.prototype` would suffice, however, using an array literal\n * avoids issues in Narwhal.\n */\nvar arrayRef = [];\n\n/** Native method shortcuts */\nvar push = arrayRef.push,\n    unshift = arrayRef.unshift;\n\n/**\n * Creates a function that, when called, either curries or invokes `func`\n * with an optional `this` binding and partially applied arguments.\n *\n * @private\n * @param {Function|string} func The function or method name to reference.\n * @param {number} bitmask The bitmask of method flags to compose.\n *  The bitmask may be composed of the following flags:\n *  1 - `_.bind`\n *  2 - `_.bindKey`\n *  4 - `_.curry`\n *  8 - `_.curry` (bound)\n *  16 - `_.partial`\n *  32 - `_.partialRight`\n * @param {Array} [partialArgs] An array of arguments to prepend to those\n *  provided to the new function.\n * @param {Array} [partialRightArgs] An array of arguments to append to those\n *  provided to the new function.\n * @param {*} [thisArg] The `this` binding of `func`.\n * @param {number} [arity] The arity of `func`.\n * @returns {Function} Returns the new function.\n */\nfunction createWrapper(func, bitmask, partialArgs, partialRightArgs, thisArg, arity) {\n  var isBind = bitmask & 1,\n      isBindKey = bitmask & 2,\n      isCurry = bitmask & 4,\n      isCurryBound = bitmask & 8,\n      isPartial = bitmask & 16,\n      isPartialRight = bitmask & 32;\n\n  if (!isBindKey && !isFunction(func)) {\n    throw new TypeError;\n  }\n  if (isPartial && !partialArgs.length) {\n    bitmask &= ~16;\n    isPartial = partialArgs = false;\n  }\n  if (isPartialRight && !partialRightArgs.length) {\n    bitmask &= ~32;\n    isPartialRight = partialRightArgs = false;\n  }\n  var bindData = func && func.__bindData__;\n  if (bindData && bindData !== true) {\n    // clone `bindData`\n    bindData = slice(bindData);\n    if (bindData[2]) {\n      bindData[2] = slice(bindData[2]);\n    }\n    if (bindData[3]) {\n      bindData[3] = slice(bindData[3]);\n    }\n    // set `thisBinding` is not previously bound\n    if (isBind && !(bindData[1] & 1)) {\n      bindData[4] = thisArg;\n    }\n    // set if previously bound but not currently (subsequent curried functions)\n    if (!isBind && bindData[1] & 1) {\n      bitmask |= 8;\n    }\n    // set curried arity if not yet set\n    if (isCurry && !(bindData[1] & 4)) {\n      bindData[5] = arity;\n    }\n    // append partial left arguments\n    if (isPartial) {\n      push.apply(bindData[2] || (bindData[2] = []), partialArgs);\n    }\n    // append partial right arguments\n    if (isPartialRight) {\n      unshift.apply(bindData[3] || (bindData[3] = []), partialRightArgs);\n    }\n    // merge flags\n    bindData[1] |= bitmask;\n    return createWrapper.apply(null, bindData);\n  }\n  // fast path for `_.bind`\n  var creater = (bitmask == 1 || bitmask === 17) ? baseBind : baseCreateWrapper;\n  return creater([func, bitmask, partialArgs, partialRightArgs, thisArg, arity]);\n}\n\nmodule.exports = createWrapper;\n\n},{\"lodash._basebind\":9,\"lodash._basecreatewrapper\":13,\"lodash._slice\":18,\"lodash.isfunction\":17}],9:[function(require,module,exports){\n/**\n * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>\n * Build: `lodash modularize modern exports=\"npm\" -o ./npm/`\n * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>\n * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>\n * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n * Available under MIT license <http://lodash.com/license>\n */\nvar baseCreate = require('lodash._basecreate'),\n    isObject = require('lodash.isobject'),\n    setBindData = require('lodash._setbinddata'),\n    slice = require('lodash._slice');\n\n/**\n * Used for `Array` method references.\n *\n * Normally `Array.prototype` would suffice, however, using an array literal\n * avoids issues in Narwhal.\n */\nvar arrayRef = [];\n\n/** Native method shortcuts */\nvar push = arrayRef.push;\n\n/**\n * The base implementation of `_.bind` that creates the bound function and\n * sets its meta data.\n *\n * @private\n * @param {Array} bindData The bind data array.\n * @returns {Function} Returns the new bound function.\n */\nfunction baseBind(bindData) {\n  var func = bindData[0],\n      partialArgs = bindData[2],\n      thisArg = bindData[4];\n\n  function bound() {\n    // `Function#bind` spec\n    // http://es5.github.io/#x15.3.4.5\n    if (partialArgs) {\n      // avoid `arguments` object deoptimizations by using `slice` instead\n      // of `Array.prototype.slice.call` and not assigning `arguments` to a\n      // variable as a ternary expression\n      var args = slice(partialArgs);\n      push.apply(args, arguments);\n    }\n    // mimic the constructor's `return` behavior\n    // http://es5.github.io/#x13.2.2\n    if (this instanceof bound) {\n      // ensure `new bound` is an instance of `func`\n      var thisBinding = baseCreate(func.prototype),\n          result = func.apply(thisBinding, args || arguments);\n      return isObject(result) ? result : thisBinding;\n    }\n    return func.apply(thisArg, args || arguments);\n  }\n  setBindData(bound, bindData);\n  return bound;\n}\n\nmodule.exports = baseBind;\n\n},{\"lodash._basecreate\":10,\"lodash._setbinddata\":4,\"lodash._slice\":18,\"lodash.isobject\":31}],10:[function(require,module,exports){\n(function (global){\n/**\n * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>\n * Build: `lodash modularize modern exports=\"npm\" -o ./npm/`\n * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>\n * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>\n * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n * Available under MIT license <http://lodash.com/license>\n */\nvar isNative = require('lodash._isnative'),\n    isObject = require('lodash.isobject'),\n    noop = require('lodash.noop');\n\n/* Native method shortcuts for methods with the same name as other `lodash` methods */\nvar nativeCreate = isNative(nativeCreate = Object.create) && nativeCreate;\n\n/**\n * The base implementation of `_.create` without support for assigning\n * properties to the created object.\n *\n * @private\n * @param {Object} prototype The object to inherit from.\n * @returns {Object} Returns the new object.\n */\nfunction baseCreate(prototype, properties) {\n  return isObject(prototype) ? nativeCreate(prototype) : {};\n}\n// fallback for browsers without `Object.create`\nif (!nativeCreate) {\n  baseCreate = (function() {\n    function Object() {}\n    return function(prototype) {\n      if (isObject(prototype)) {\n        Object.prototype = prototype;\n        var result = new Object;\n        Object.prototype = null;\n      }\n      return result || global.Object();\n    };\n  }());\n}\n\nmodule.exports = baseCreate;\n\n}).call(this,typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"lodash._isnative\":11,\"lodash.isobject\":31,\"lodash.noop\":12}],11:[function(require,module,exports){\nmodule.exports=require(5)\n},{}],12:[function(require,module,exports){\nmodule.exports=require(6)\n},{}],13:[function(require,module,exports){\n/**\n * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>\n * Build: `lodash modularize modern exports=\"npm\" -o ./npm/`\n * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>\n * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>\n * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n * Available under MIT license <http://lodash.com/license>\n */\nvar baseCreate = require('lodash._basecreate'),\n    isObject = require('lodash.isobject'),\n    setBindData = require('lodash._setbinddata'),\n    slice = require('lodash._slice');\n\n/**\n * Used for `Array` method references.\n *\n * Normally `Array.prototype` would suffice, however, using an array literal\n * avoids issues in Narwhal.\n */\nvar arrayRef = [];\n\n/** Native method shortcuts */\nvar push = arrayRef.push;\n\n/**\n * The base implementation of `createWrapper` that creates the wrapper and\n * sets its meta data.\n *\n * @private\n * @param {Array} bindData The bind data array.\n * @returns {Function} Returns the new function.\n */\nfunction baseCreateWrapper(bindData) {\n  var func = bindData[0],\n      bitmask = bindData[1],\n      partialArgs = bindData[2],\n      partialRightArgs = bindData[3],\n      thisArg = bindData[4],\n      arity = bindData[5];\n\n  var isBind = bitmask & 1,\n      isBindKey = bitmask & 2,\n      isCurry = bitmask & 4,\n      isCurryBound = bitmask & 8,\n      key = func;\n\n  function bound() {\n    var thisBinding = isBind ? thisArg : this;\n    if (partialArgs) {\n      var args = slice(partialArgs);\n      push.apply(args, arguments);\n    }\n    if (partialRightArgs || isCurry) {\n      args || (args = slice(arguments));\n      if (partialRightArgs) {\n        push.apply(args, partialRightArgs);\n      }\n      if (isCurry && args.length < arity) {\n        bitmask |= 16 & ~32;\n        return baseCreateWrapper([func, (isCurryBound ? bitmask : bitmask & ~3), args, null, thisArg, arity]);\n      }\n    }\n    args || (args = arguments);\n    if (isBindKey) {\n      func = thisBinding[key];\n    }\n    if (this instanceof bound) {\n      thisBinding = baseCreate(func.prototype);\n      var result = func.apply(thisBinding, args);\n      return isObject(result) ? result : thisBinding;\n    }\n    return func.apply(thisBinding, args);\n  }\n  setBindData(bound, bindData);\n  return bound;\n}\n\nmodule.exports = baseCreateWrapper;\n\n},{\"lodash._basecreate\":14,\"lodash._setbinddata\":4,\"lodash._slice\":18,\"lodash.isobject\":31}],14:[function(require,module,exports){\nmodule.exports=require(10)\n},{\"lodash._isnative\":15,\"lodash.isobject\":31,\"lodash.noop\":16}],15:[function(require,module,exports){\nmodule.exports=require(5)\n},{}],16:[function(require,module,exports){\nmodule.exports=require(6)\n},{}],17:[function(require,module,exports){\n/**\n * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>\n * Build: `lodash modularize modern exports=\"npm\" -o ./npm/`\n * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>\n * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>\n * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n * Available under MIT license <http://lodash.com/license>\n */\n\n/**\n * Checks if `value` is a function.\n *\n * @static\n * @memberOf _\n * @category Objects\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if the `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n */\nfunction isFunction(value) {\n  return typeof value == 'function';\n}\n\nmodule.exports = isFunction;\n\n},{}],18:[function(require,module,exports){\n/**\n * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>\n * Build: `lodash modularize modern exports=\"npm\" -o ./npm/`\n * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>\n * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>\n * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n * Available under MIT license <http://lodash.com/license>\n */\n\n/**\n * Slices the `collection` from the `start` index up to, but not including,\n * the `end` index.\n *\n * Note: This function is used instead of `Array#slice` to support node lists\n * in IE < 9 and to ensure dense arrays are returned.\n *\n * @private\n * @param {Array|Object|string} collection The collection to slice.\n * @param {number} start The start index.\n * @param {number} end The end index.\n * @returns {Array} Returns the new array.\n */\nfunction slice(array, start, end) {\n  start || (start = 0);\n  if (typeof end == 'undefined') {\n    end = array ? array.length : 0;\n  }\n  var index = -1,\n      length = end - start || 0,\n      result = Array(length < 0 ? 0 : length);\n\n  while (++index < length) {\n    result[index] = array[start + index];\n  }\n  return result;\n}\n\nmodule.exports = slice;\n\n},{}],19:[function(require,module,exports){\n/**\n * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>\n * Build: `lodash modularize modern exports=\"npm\" -o ./npm/`\n * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>\n * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>\n * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n * Available under MIT license <http://lodash.com/license>\n */\n\n/**\n * This method returns the first argument provided to it.\n *\n * @static\n * @memberOf _\n * @category Utilities\n * @param {*} value Any value.\n * @returns {*} Returns `value`.\n * @example\n *\n * var object = { 'name': 'fred' };\n * _.identity(object) === object;\n * // => true\n */\nfunction identity(value) {\n  return value;\n}\n\nmodule.exports = identity;\n\n},{}],20:[function(require,module,exports){\n(function (global){\n/**\n * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>\n * Build: `lodash modularize modern exports=\"npm\" -o ./npm/`\n * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>\n * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>\n * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n * Available under MIT license <http://lodash.com/license>\n */\nvar isNative = require('lodash._isnative');\n\n/** Used to detect functions containing a `this` reference */\nvar reThis = /\\bthis\\b/;\n\n/**\n * An object used to flag environments features.\n *\n * @static\n * @memberOf _\n * @type Object\n */\nvar support = {};\n\n/**\n * Detect if functions can be decompiled by `Function#toString`\n * (all but PS3 and older Opera mobile browsers & avoided in Windows 8 apps).\n *\n * @memberOf _.support\n * @type boolean\n */\nsupport.funcDecomp = !isNative(global.WinRTError) && reThis.test(function() { return this; });\n\n/**\n * Detect if `Function#name` is supported (all but IE).\n *\n * @memberOf _.support\n * @type boolean\n */\nsupport.funcNames = typeof Function.name == 'string';\n\nmodule.exports = support;\n\n}).call(this,typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"lodash._isnative\":21}],21:[function(require,module,exports){\nmodule.exports=require(5)\n},{}],22:[function(require,module,exports){\n/**\n * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>\n * Build: `lodash modularize modern exports=\"npm\" -o ./npm/`\n * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>\n * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>\n * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n * Available under MIT license <http://lodash.com/license>\n */\nvar forIn = require('lodash.forin'),\n    getArray = require('lodash._getarray'),\n    isFunction = require('lodash.isfunction'),\n    objectTypes = require('lodash._objecttypes'),\n    releaseArray = require('lodash._releasearray');\n\n/** `Object#toString` result shortcuts */\nvar argsClass = '[object Arguments]',\n    arrayClass = '[object Array]',\n    boolClass = '[object Boolean]',\n    dateClass = '[object Date]',\n    numberClass = '[object Number]',\n    objectClass = '[object Object]',\n    regexpClass = '[object RegExp]',\n    stringClass = '[object String]';\n\n/** Used for native method references */\nvar objectProto = Object.prototype;\n\n/** Used to resolve the internal [[Class]] of values */\nvar toString = objectProto.toString;\n\n/** Native method shortcuts */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * The base implementation of `_.isEqual`, without support for `thisArg` binding,\n * that allows partial \"_.where\" style comparisons.\n *\n * @private\n * @param {*} a The value to compare.\n * @param {*} b The other value to compare.\n * @param {Function} [callback] The function to customize comparing values.\n * @param {Function} [isWhere=false] A flag to indicate performing partial comparisons.\n * @param {Array} [stackA=[]] Tracks traversed `a` objects.\n * @param {Array} [stackB=[]] Tracks traversed `b` objects.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n */\nfunction baseIsEqual(a, b, callback, isWhere, stackA, stackB) {\n  // used to indicate that when comparing objects, `a` has at least the properties of `b`\n  if (callback) {\n    var result = callback(a, b);\n    if (typeof result != 'undefined') {\n      return !!result;\n    }\n  }\n  // exit early for identical values\n  if (a === b) {\n    // treat `+0` vs. `-0` as not equal\n    return a !== 0 || (1 / a == 1 / b);\n  }\n  var type = typeof a,\n      otherType = typeof b;\n\n  // exit early for unlike primitive values\n  if (a === a &&\n      !(a && objectTypes[type]) &&\n      !(b && objectTypes[otherType])) {\n    return false;\n  }\n  // exit early for `null` and `undefined` avoiding ES3's Function#call behavior\n  // http://es5.github.io/#x15.3.4.4\n  if (a == null || b == null) {\n    return a === b;\n  }\n  // compare [[Class]] names\n  var className = toString.call(a),\n      otherClass = toString.call(b);\n\n  if (className == argsClass) {\n    className = objectClass;\n  }\n  if (otherClass == argsClass) {\n    otherClass = objectClass;\n  }\n  if (className != otherClass) {\n    return false;\n  }\n  switch (className) {\n    case boolClass:\n    case dateClass:\n      // coerce dates and booleans to numbers, dates to milliseconds and booleans\n      // to `1` or `0` treating invalid dates coerced to `NaN` as not equal\n      return +a == +b;\n\n    case numberClass:\n      // treat `NaN` vs. `NaN` as equal\n      return (a != +a)\n        ? b != +b\n        // but treat `+0` vs. `-0` as not equal\n        : (a == 0 ? (1 / a == 1 / b) : a == +b);\n\n    case regexpClass:\n    case stringClass:\n      // coerce regexes to strings (http://es5.github.io/#x15.10.6.4)\n      // treat string primitives and their corresponding object instances as equal\n      return a == String(b);\n  }\n  var isArr = className == arrayClass;\n  if (!isArr) {\n    // unwrap any `lodash` wrapped values\n    var aWrapped = hasOwnProperty.call(a, '__wrapped__'),\n        bWrapped = hasOwnProperty.call(b, '__wrapped__');\n\n    if (aWrapped || bWrapped) {\n      return baseIsEqual(aWrapped ? a.__wrapped__ : a, bWrapped ? b.__wrapped__ : b, callback, isWhere, stackA, stackB);\n    }\n    // exit for functions and DOM nodes\n    if (className != objectClass) {\n      return false;\n    }\n    // in older versions of Opera, `arguments` objects have `Array` constructors\n    var ctorA = a.constructor,\n        ctorB = b.constructor;\n\n    // non `Object` object instances with different constructors are not equal\n    if (ctorA != ctorB &&\n          !(isFunction(ctorA) && ctorA instanceof ctorA && isFunction(ctorB) && ctorB instanceof ctorB) &&\n          ('constructor' in a && 'constructor' in b)\n        ) {\n      return false;\n    }\n  }\n  // assume cyclic structures are equal\n  // the algorithm for detecting cyclic structures is adapted from ES 5.1\n  // section 15.12.3, abstract operation `JO` (http://es5.github.io/#x15.12.3)\n  var initedStack = !stackA;\n  stackA || (stackA = getArray());\n  stackB || (stackB = getArray());\n\n  var length = stackA.length;\n  while (length--) {\n    if (stackA[length] == a) {\n      return stackB[length] == b;\n    }\n  }\n  var size = 0;\n  result = true;\n\n  // add `a` and `b` to the stack of traversed objects\n  stackA.push(a);\n  stackB.push(b);\n\n  // recursively compare objects and arrays (susceptible to call stack limits)\n  if (isArr) {\n    // compare lengths to determine if a deep comparison is necessary\n    length = a.length;\n    size = b.length;\n    result = size == length;\n\n    if (result || isWhere) {\n      // deep compare the contents, ignoring non-numeric properties\n      while (size--) {\n        var index = length,\n            value = b[size];\n\n        if (isWhere) {\n          while (index--) {\n            if ((result = baseIsEqual(a[index], value, callback, isWhere, stackA, stackB))) {\n              break;\n            }\n          }\n        } else if (!(result = baseIsEqual(a[size], value, callback, isWhere, stackA, stackB))) {\n          break;\n        }\n      }\n    }\n  }\n  else {\n    // deep compare objects using `forIn`, instead of `forOwn`, to avoid `Object.keys`\n    // which, in this case, is more costly\n    forIn(b, function(value, key, b) {\n      if (hasOwnProperty.call(b, key)) {\n        // count the number of properties.\n        size++;\n        // deep compare each property value.\n        return (result = hasOwnProperty.call(a, key) && baseIsEqual(a[key], value, callback, isWhere, stackA, stackB));\n      }\n    });\n\n    if (result && !isWhere) {\n      // ensure both objects have the same number of properties\n      forIn(a, function(value, key, a) {\n        if (hasOwnProperty.call(a, key)) {\n          // `size` will be `-1` if `a` has more properties than `b`\n          return (result = --size > -1);\n        }\n      });\n    }\n  }\n  stackA.pop();\n  stackB.pop();\n\n  if (initedStack) {\n    releaseArray(stackA);\n    releaseArray(stackB);\n  }\n  return result;\n}\n\nmodule.exports = baseIsEqual;\n\n},{\"lodash._getarray\":23,\"lodash._objecttypes\":25,\"lodash._releasearray\":26,\"lodash.forin\":29,\"lodash.isfunction\":30}],23:[function(require,module,exports){\n/**\n * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>\n * Build: `lodash modularize modern exports=\"npm\" -o ./npm/`\n * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>\n * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>\n * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n * Available under MIT license <http://lodash.com/license>\n */\nvar arrayPool = require('lodash._arraypool');\n\n/**\n * Gets an array from the array pool or creates a new one if the pool is empty.\n *\n * @private\n * @returns {Array} The array from the pool.\n */\nfunction getArray() {\n  return arrayPool.pop() || [];\n}\n\nmodule.exports = getArray;\n\n},{\"lodash._arraypool\":24}],24:[function(require,module,exports){\n/**\n * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>\n * Build: `lodash modularize modern exports=\"npm\" -o ./npm/`\n * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>\n * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>\n * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n * Available under MIT license <http://lodash.com/license>\n */\n\n/** Used to pool arrays and objects used internally */\nvar arrayPool = [];\n\nmodule.exports = arrayPool;\n\n},{}],25:[function(require,module,exports){\n/**\n * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>\n * Build: `lodash modularize modern exports=\"npm\" -o ./npm/`\n * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>\n * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>\n * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n * Available under MIT license <http://lodash.com/license>\n */\n\n/** Used to determine if values are of the language type Object */\nvar objectTypes = {\n  'boolean': false,\n  'function': true,\n  'object': true,\n  'number': false,\n  'string': false,\n  'undefined': false\n};\n\nmodule.exports = objectTypes;\n\n},{}],26:[function(require,module,exports){\n/**\n * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>\n * Build: `lodash modularize modern exports=\"npm\" -o ./npm/`\n * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>\n * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>\n * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n * Available under MIT license <http://lodash.com/license>\n */\nvar arrayPool = require('lodash._arraypool'),\n    maxPoolSize = require('lodash._maxpoolsize');\n\n/**\n * Releases the given array back to the array pool.\n *\n * @private\n * @param {Array} [array] The array to release.\n */\nfunction releaseArray(array) {\n  array.length = 0;\n  if (arrayPool.length < maxPoolSize) {\n    arrayPool.push(array);\n  }\n}\n\nmodule.exports = releaseArray;\n\n},{\"lodash._arraypool\":27,\"lodash._maxpoolsize\":28}],27:[function(require,module,exports){\nmodule.exports=require(24)\n},{}],28:[function(require,module,exports){\n/**\n * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>\n * Build: `lodash modularize modern exports=\"npm\" -o ./npm/`\n * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>\n * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>\n * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n * Available under MIT license <http://lodash.com/license>\n */\n\n/** Used as the max size of the `arrayPool` and `objectPool` */\nvar maxPoolSize = 40;\n\nmodule.exports = maxPoolSize;\n\n},{}],29:[function(require,module,exports){\n/**\n * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>\n * Build: `lodash modularize modern exports=\"npm\" -o ./npm/`\n * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>\n * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>\n * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n * Available under MIT license <http://lodash.com/license>\n */\nvar baseCreateCallback = require('lodash._basecreatecallback'),\n    objectTypes = require('lodash._objecttypes');\n\n/**\n * Iterates over own and inherited enumerable properties of an object,\n * executing the callback for each property. The callback is bound to `thisArg`\n * and invoked with three arguments; (value, key, object). Callbacks may exit\n * iteration early by explicitly returning `false`.\n *\n * @static\n * @memberOf _\n * @type Function\n * @category Objects\n * @param {Object} object The object to iterate over.\n * @param {Function} [callback=identity] The function called per iteration.\n * @param {*} [thisArg] The `this` binding of `callback`.\n * @returns {Object} Returns `object`.\n * @example\n *\n * function Shape() {\n *   this.x = 0;\n *   this.y = 0;\n * }\n *\n * Shape.prototype.move = function(x, y) {\n *   this.x += x;\n *   this.y += y;\n * };\n *\n * _.forIn(new Shape, function(value, key) {\n *   console.log(key);\n * });\n * // => logs 'x', 'y', and 'move' (property order is not guaranteed across environments)\n */\nvar forIn = function(collection, callback, thisArg) {\n  var index, iterable = collection, result = iterable;\n  if (!iterable) return result;\n  if (!objectTypes[typeof iterable]) return result;\n  callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);\n    for (index in iterable) {\n      if (callback(iterable[index], index, collection) === false) return result;\n    }\n  return result\n};\n\nmodule.exports = forIn;\n\n},{\"lodash._basecreatecallback\":3,\"lodash._objecttypes\":25}],30:[function(require,module,exports){\nmodule.exports=require(17)\n},{}],31:[function(require,module,exports){\n/**\n * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>\n * Build: `lodash modularize modern exports=\"npm\" -o ./npm/`\n * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>\n * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>\n * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n * Available under MIT license <http://lodash.com/license>\n */\nvar objectTypes = require('lodash._objecttypes');\n\n/**\n * Checks if `value` is the language type of Object.\n * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @category Objects\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if the `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(1);\n * // => false\n */\nfunction isObject(value) {\n  // check if the value is the ECMAScript language type of Object\n  // http://es5.github.io/#x8\n  // and avoid a V8 bug\n  // http://code.google.com/p/v8/issues/detail?id=2291\n  return !!(value && objectTypes[typeof value]);\n}\n\nmodule.exports = isObject;\n\n},{\"lodash._objecttypes\":32}],32:[function(require,module,exports){\nmodule.exports=require(25)\n},{}],33:[function(require,module,exports){\n/**\n * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>\n * Build: `lodash modularize modern exports=\"npm\" -o ./npm/`\n * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>\n * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>\n * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n * Available under MIT license <http://lodash.com/license>\n */\nvar isNative = require('lodash._isnative'),\n    isObject = require('lodash.isobject'),\n    shimKeys = require('lodash._shimkeys');\n\n/* Native method shortcuts for methods with the same name as other `lodash` methods */\nvar nativeKeys = isNative(nativeKeys = Object.keys) && nativeKeys;\n\n/**\n * Creates an array composed of the own enumerable property names of an object.\n *\n * @static\n * @memberOf _\n * @category Objects\n * @param {Object} object The object to inspect.\n * @returns {Array} Returns an array of property names.\n * @example\n *\n * _.keys({ 'one': 1, 'two': 2, 'three': 3 });\n * // => ['one', 'two', 'three'] (property order is not guaranteed across environments)\n */\nvar keys = !nativeKeys ? shimKeys : function(object) {\n  if (!isObject(object)) {\n    return [];\n  }\n  return nativeKeys(object);\n};\n\nmodule.exports = keys;\n\n},{\"lodash._isnative\":34,\"lodash._shimkeys\":35,\"lodash.isobject\":31}],34:[function(require,module,exports){\nmodule.exports=require(5)\n},{}],35:[function(require,module,exports){\n/**\n * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>\n * Build: `lodash modularize modern exports=\"npm\" -o ./npm/`\n * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>\n * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>\n * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n * Available under MIT license <http://lodash.com/license>\n */\nvar objectTypes = require('lodash._objecttypes');\n\n/** Used for native method references */\nvar objectProto = Object.prototype;\n\n/** Native method shortcuts */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * A fallback implementation of `Object.keys` which produces an array of the\n * given object's own enumerable property names.\n *\n * @private\n * @type Function\n * @param {Object} object The object to inspect.\n * @returns {Array} Returns an array of property names.\n */\nvar shimKeys = function(object) {\n  var index, iterable = object, result = [];\n  if (!iterable) return result;\n  if (!(objectTypes[typeof object])) return result;\n    for (index in iterable) {\n      if (hasOwnProperty.call(iterable, index)) {\n        result.push(index);\n      }\n    }\n  return result\n};\n\nmodule.exports = shimKeys;\n\n},{\"lodash._objecttypes\":36}],36:[function(require,module,exports){\nmodule.exports=require(25)\n},{}],37:[function(require,module,exports){\n/**\n * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>\n * Build: `lodash modularize modern exports=\"npm\" -o ./npm/`\n * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>\n * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>\n * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n * Available under MIT license <http://lodash.com/license>\n */\n\n/**\n * Creates a \"_.pluck\" style function, which returns the `key` value of a\n * given object.\n *\n * @static\n * @memberOf _\n * @category Utilities\n * @param {string} key The name of the property to retrieve.\n * @returns {Function} Returns the new function.\n * @example\n *\n * var characters = [\n *   { 'name': 'fred',   'age': 40 },\n *   { 'name': 'barney', 'age': 36 }\n * ];\n *\n * var getName = _.property('name');\n *\n * _.map(characters, getName);\n * // => ['barney', 'fred']\n *\n * _.sortBy(characters, getName);\n * // => [{ 'name': 'barney', 'age': 36 }, { 'name': 'fred',   'age': 40 }]\n */\nfunction property(key) {\n  return function(object) {\n    return object[key];\n  };\n}\n\nmodule.exports = property;\n\n},{}],38:[function(require,module,exports){\n/**\n * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>\n * Build: `lodash modularize modern exports=\"npm\" -o ./npm/`\n * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>\n * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>\n * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n * Available under MIT license <http://lodash.com/license>\n */\nvar baseCreateCallback = require('lodash._basecreatecallback'),\n    keys = require('lodash.keys'),\n    objectTypes = require('lodash._objecttypes');\n\n/**\n * Iterates over own enumerable properties of an object, executing the callback\n * for each property. The callback is bound to `thisArg` and invoked with three\n * arguments; (value, key, object). Callbacks may exit iteration early by\n * explicitly returning `false`.\n *\n * @static\n * @memberOf _\n * @type Function\n * @category Objects\n * @param {Object} object The object to iterate over.\n * @param {Function} [callback=identity] The function called per iteration.\n * @param {*} [thisArg] The `this` binding of `callback`.\n * @returns {Object} Returns `object`.\n * @example\n *\n * _.forOwn({ '0': 'zero', '1': 'one', 'length': 2 }, function(num, key) {\n *   console.log(key);\n * });\n * // => logs '0', '1', and 'length' (property order is not guaranteed across environments)\n */\nvar forOwn = function(collection, callback, thisArg) {\n  var index, iterable = collection, result = iterable;\n  if (!iterable) return result;\n  if (!objectTypes[typeof iterable]) return result;\n  callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);\n    var ownIndex = -1,\n        ownProps = objectTypes[typeof iterable] && keys(iterable),\n        length = ownProps ? ownProps.length : 0;\n\n    while (++ownIndex < length) {\n      index = ownProps[ownIndex];\n      if (callback(iterable[index], index, collection) === false) return result;\n    }\n  return result\n};\n\nmodule.exports = forOwn;\n\n},{\"lodash._basecreatecallback\":39,\"lodash._objecttypes\":60,\"lodash.keys\":61}],39:[function(require,module,exports){\nmodule.exports=require(3)\n},{\"lodash._setbinddata\":40,\"lodash.bind\":43,\"lodash.identity\":57,\"lodash.support\":58}],40:[function(require,module,exports){\nmodule.exports=require(4)\n},{\"lodash._isnative\":41,\"lodash.noop\":42}],41:[function(require,module,exports){\nmodule.exports=require(5)\n},{}],42:[function(require,module,exports){\nmodule.exports=require(6)\n},{}],43:[function(require,module,exports){\nmodule.exports=require(7)\n},{\"lodash._createwrapper\":44,\"lodash._slice\":56}],44:[function(require,module,exports){\nmodule.exports=require(8)\n},{\"lodash._basebind\":45,\"lodash._basecreatewrapper\":50,\"lodash._slice\":56,\"lodash.isfunction\":55}],45:[function(require,module,exports){\nmodule.exports=require(9)\n},{\"lodash._basecreate\":46,\"lodash._setbinddata\":40,\"lodash._slice\":56,\"lodash.isobject\":49}],46:[function(require,module,exports){\nmodule.exports=require(10)\n},{\"lodash._isnative\":47,\"lodash.isobject\":49,\"lodash.noop\":48}],47:[function(require,module,exports){\nmodule.exports=require(5)\n},{}],48:[function(require,module,exports){\nmodule.exports=require(6)\n},{}],49:[function(require,module,exports){\nmodule.exports=require(31)\n},{\"lodash._objecttypes\":60}],50:[function(require,module,exports){\nmodule.exports=require(13)\n},{\"lodash._basecreate\":51,\"lodash._setbinddata\":40,\"lodash._slice\":56,\"lodash.isobject\":54}],51:[function(require,module,exports){\nmodule.exports=require(10)\n},{\"lodash._isnative\":52,\"lodash.isobject\":54,\"lodash.noop\":53}],52:[function(require,module,exports){\nmodule.exports=require(5)\n},{}],53:[function(require,module,exports){\nmodule.exports=require(6)\n},{}],54:[function(require,module,exports){\nmodule.exports=require(31)\n},{\"lodash._objecttypes\":60}],55:[function(require,module,exports){\nmodule.exports=require(17)\n},{}],56:[function(require,module,exports){\nmodule.exports=require(18)\n},{}],57:[function(require,module,exports){\nmodule.exports=require(19)\n},{}],58:[function(require,module,exports){\nmodule.exports=require(20)\n},{\"lodash._isnative\":59}],59:[function(require,module,exports){\nmodule.exports=require(5)\n},{}],60:[function(require,module,exports){\nmodule.exports=require(25)\n},{}],61:[function(require,module,exports){\nmodule.exports=require(33)\n},{\"lodash._isnative\":62,\"lodash._shimkeys\":63,\"lodash.isobject\":64}],62:[function(require,module,exports){\nmodule.exports=require(5)\n},{}],63:[function(require,module,exports){\nmodule.exports=require(35)\n},{\"lodash._objecttypes\":60}],64:[function(require,module,exports){\nmodule.exports=require(31)\n},{\"lodash._objecttypes\":60}],65:[function(require,module,exports){\n/**\n * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>\n * Build: `lodash modularize modern exports=\"npm\" -o ./npm/`\n * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>\n * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>\n * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n * Available under MIT license <http://lodash.com/license>\n */\nvar createCallback = require('lodash.createcallback');\n\n/**\n * Used for `Array` method references.\n *\n * Normally `Array.prototype` would suffice, however, using an array literal\n * avoids issues in Narwhal.\n */\nvar arrayRef = [];\n\n/** Native method shortcuts */\nvar splice = arrayRef.splice;\n\n/**\n * Removes all elements from an array that the callback returns truey for\n * and returns an array of removed elements. The callback is bound to `thisArg`\n * and invoked with three arguments; (value, index, array).\n *\n * If a property name is provided for `callback` the created \"_.pluck\" style\n * callback will return the property value of the given element.\n *\n * If an object is provided for `callback` the created \"_.where\" style callback\n * will return `true` for elements that have the properties of the given object,\n * else `false`.\n *\n * @static\n * @memberOf _\n * @category Arrays\n * @param {Array} array The array to modify.\n * @param {Function|Object|string} [callback=identity] The function called\n *  per iteration. If a property name or object is provided it will be used\n *  to create a \"_.pluck\" or \"_.where\" style callback, respectively.\n * @param {*} [thisArg] The `this` binding of `callback`.\n * @returns {Array} Returns a new array of removed elements.\n * @example\n *\n * var array = [1, 2, 3, 4, 5, 6];\n * var evens = _.remove(array, function(num) { return num % 2 == 0; });\n *\n * console.log(array);\n * // => [1, 3, 5]\n *\n * console.log(evens);\n * // => [2, 4, 6]\n */\nfunction remove(array, callback, thisArg) {\n  var index = -1,\n      length = array ? array.length : 0,\n      result = [];\n\n  callback = createCallback(callback, thisArg, 3);\n  while (++index < length) {\n    var value = array[index];\n    if (callback(value, index, array)) {\n      result.push(value);\n      splice.call(array, index--, 1);\n      length--;\n    }\n  }\n  return result;\n}\n\nmodule.exports = remove;\n\n},{\"lodash.createcallback\":66}],66:[function(require,module,exports){\nmodule.exports=require(2)\n},{\"lodash._basecreatecallback\":67,\"lodash._baseisequal\":86,\"lodash.isobject\":95,\"lodash.keys\":97,\"lodash.property\":101}],67:[function(require,module,exports){\nmodule.exports=require(3)\n},{\"lodash._setbinddata\":68,\"lodash.bind\":71,\"lodash.identity\":83,\"lodash.support\":84}],68:[function(require,module,exports){\nmodule.exports=require(4)\n},{\"lodash._isnative\":69,\"lodash.noop\":70}],69:[function(require,module,exports){\nmodule.exports=require(5)\n},{}],70:[function(require,module,exports){\nmodule.exports=require(6)\n},{}],71:[function(require,module,exports){\nmodule.exports=require(7)\n},{\"lodash._createwrapper\":72,\"lodash._slice\":82}],72:[function(require,module,exports){\nmodule.exports=require(8)\n},{\"lodash._basebind\":73,\"lodash._basecreatewrapper\":77,\"lodash._slice\":82,\"lodash.isfunction\":81}],73:[function(require,module,exports){\nmodule.exports=require(9)\n},{\"lodash._basecreate\":74,\"lodash._setbinddata\":68,\"lodash._slice\":82,\"lodash.isobject\":95}],74:[function(require,module,exports){\nmodule.exports=require(10)\n},{\"lodash._isnative\":75,\"lodash.isobject\":95,\"lodash.noop\":76}],75:[function(require,module,exports){\nmodule.exports=require(5)\n},{}],76:[function(require,module,exports){\nmodule.exports=require(6)\n},{}],77:[function(require,module,exports){\nmodule.exports=require(13)\n},{\"lodash._basecreate\":78,\"lodash._setbinddata\":68,\"lodash._slice\":82,\"lodash.isobject\":95}],78:[function(require,module,exports){\nmodule.exports=require(10)\n},{\"lodash._isnative\":79,\"lodash.isobject\":95,\"lodash.noop\":80}],79:[function(require,module,exports){\nmodule.exports=require(5)\n},{}],80:[function(require,module,exports){\nmodule.exports=require(6)\n},{}],81:[function(require,module,exports){\nmodule.exports=require(17)\n},{}],82:[function(require,module,exports){\nmodule.exports=require(18)\n},{}],83:[function(require,module,exports){\nmodule.exports=require(19)\n},{}],84:[function(require,module,exports){\nmodule.exports=require(20)\n},{\"lodash._isnative\":85}],85:[function(require,module,exports){\nmodule.exports=require(5)\n},{}],86:[function(require,module,exports){\nmodule.exports=require(22)\n},{\"lodash._getarray\":87,\"lodash._objecttypes\":89,\"lodash._releasearray\":90,\"lodash.forin\":93,\"lodash.isfunction\":94}],87:[function(require,module,exports){\nmodule.exports=require(23)\n},{\"lodash._arraypool\":88}],88:[function(require,module,exports){\nmodule.exports=require(24)\n},{}],89:[function(require,module,exports){\nmodule.exports=require(25)\n},{}],90:[function(require,module,exports){\nmodule.exports=require(26)\n},{\"lodash._arraypool\":91,\"lodash._maxpoolsize\":92}],91:[function(require,module,exports){\nmodule.exports=require(24)\n},{}],92:[function(require,module,exports){\nmodule.exports=require(28)\n},{}],93:[function(require,module,exports){\nmodule.exports=require(29)\n},{\"lodash._basecreatecallback\":67,\"lodash._objecttypes\":89}],94:[function(require,module,exports){\nmodule.exports=require(17)\n},{}],95:[function(require,module,exports){\nmodule.exports=require(31)\n},{\"lodash._objecttypes\":96}],96:[function(require,module,exports){\nmodule.exports=require(25)\n},{}],97:[function(require,module,exports){\nmodule.exports=require(33)\n},{\"lodash._isnative\":98,\"lodash._shimkeys\":99,\"lodash.isobject\":95}],98:[function(require,module,exports){\nmodule.exports=require(5)\n},{}],99:[function(require,module,exports){\nmodule.exports=require(35)\n},{\"lodash._objecttypes\":100}],100:[function(require,module,exports){\nmodule.exports=require(25)\n},{}],101:[function(require,module,exports){\nmodule.exports=require(37)\n},{}],102:[function(require,module,exports){\nvar Point, Segment, find, remove;\n\nfind = require('lodash.find');\n\nremove = require('lodash.remove');\n\nPoint = (function() {\n  function Point(x, y) {\n    this.x = x;\n    this.y = y;\n    this.segments = [];\n  }\n\n  Point.prototype.addSegment = function(seg, rel) {\n    return this.segments.push({\n      seg: seg,\n      rel: rel\n    });\n  };\n\n  return Point;\n\n})();\n\nSegment = (function() {\n  function Segment(start, end) {\n    this.start = start;\n    this.end = end;\n    this.start.addSegment(this, 'start');\n    this.end.addSegment(this, 'end');\n  }\n\n  Segment.prototype.addArc = function(radius, largeArc, sweep) {\n    this.radius = radius;\n    this.largeArc = largeArc;\n    this.sweep = sweep;\n  };\n\n  Segment.prototype.drawTo = function(point) {\n    var sw, toEnd, toStart;\n    if (point === this.start) {\n      toStart = true;\n    } else if (point === this.end) {\n      toEnd = true;\n    }\n    if ((this.radius == null) && (toStart || toEnd)) {\n      return ['L', point.x, point.y];\n    } else if ((this.radius != null) && toEnd) {\n      return ['A', this.radius, this.radius, 0, this.largeArc, this.sweep, point.x, point.y];\n    } else if ((this.radius != null) && toStart) {\n      sw = this.sweep === 1 ? 0 : 1;\n      return ['A', this.radius, this.radius, 0, this.largeArc, sw, point.x, point.y];\n    } else {\n      return [];\n    }\n  };\n\n  return Segment;\n\n})();\n\nmodule.exports = function(outline) {\n  var end, i, lrgArc, newEnd, newPath, newStart, nextPoint, nextPointRel, nextSeg, nextSegObj, nextSegRel, p, pathStart, points, r, seg, start, startPoint, sweep, x, y, _i, _len, _ref;\n  if (outline[0] !== 'M') {\n    console.log(\"didn't start with 'M'\");\n    return [];\n  }\n  pathStart = null;\n  points = [];\n  i = 0;\n  while (i < outline.length - 1) {\n    if (outline[i] === 'M' || outline[i] === 'L') {\n      x = outline[i + 1];\n      y = outline[i + 2];\n      i += 3;\n    } else if (outline[i] === 'A') {\n      x = outline[i + 6];\n      y = outline[i + 7];\n      i += 8;\n    } else if (outline[i] === 'Z') {\n      i++;\n      continue;\n    }\n    if (i >= outline.length) {\n      break;\n    } else {\n      start = find(points, {\n        x: x,\n        y: y\n      });\n      if (start == null) {\n        newStart = true;\n        start = new Point(x, y);\n      }\n    }\n    if (outline[i] === 'L') {\n      x = outline[i + 1];\n      y = outline[i + 2];\n      r = null;\n    } else if (outline[i] === 'A') {\n      x = outline[i + 6];\n      y = outline[i + 7];\n      r = outline[i + 2];\n      lrgArc = outline[i + 4];\n      sweep = outline[i + 5];\n    } else if (outline[i] === 'M') {\n      continue;\n    }\n    if (outline[i] === 'Z') {\n      end = pathStart;\n      pathStart = null;\n    } else {\n      if (pathStart == null) {\n        pathStart = start;\n      }\n      end = find(points, {\n        x: x,\n        y: y\n      });\n      if (end == null) {\n        newEnd = true;\n        end = new Point(x, y);\n      }\n    }\n    seg = new Segment(start, end);\n    if (r != null) {\n      seg.addArc(r, lrgArc, sweep);\n    }\n    if (newStart) {\n      newStart = false;\n      points.push(start);\n    }\n    if (newEnd) {\n      newEnd = false;\n      points.push(end);\n    }\n  }\n  newPath = [];\n  while (points.length) {\n    startPoint = points.pop();\n    nextSegObj = startPoint.segments.pop();\n    nextPoint = null;\n    newPath.push('M', startPoint.x, startPoint.y);\n    while (nextPoint !== startPoint) {\n      remove(points, function(p) {\n        return p === nextPoint;\n      });\n      nextSeg = nextSegObj.seg;\n      nextSegRel = nextSegObj.rel;\n      nextPointRel = nextSegRel === 'start' ? 'end' : 'start';\n      nextPoint = nextSeg[nextPointRel];\n      _ref = nextSeg.drawTo(nextPoint);\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        p = _ref[_i];\n        newPath.push(p);\n      }\n      remove(nextPoint.segments, function(sO) {\n        return sO.seg === nextSeg;\n      });\n      nextSegObj = nextPoint.segments.pop();\n    }\n  }\n  return newPath;\n};\n\n\n\n},{\"lodash.find\":1,\"lodash.remove\":65}],103:[function(require,module,exports){\nvar boardOutline, reCOPPER, reDRILL, reEDGE, reMASK, rePASTE, reSILK, unique, uniqueId;\n\nboardOutline = require('./build-board-outline.coffee');\n\nunique = 0;\n\nuniqueId = function() {\n  return unique++;\n};\n\nreCOPPER = /cu/;\n\nreMASK = /sm/;\n\nreSILK = /ss/;\n\nrePASTE = /sp/;\n\nreEDGE = /out/;\n\nreDRILL = /drl/;\n\nmodule.exports = function(name, layers) {\n  var addVboxToBbox, attr, bbox, bboxRect, copper, cuFinishId, d, defs, draw, drill, e, edge, edgeBbox, getVboxFromBbox, group, key, layer, layerId, ly, mask, mechId, mechMask, n, newPathData, node, oldSW, paste, path, scale, silk, smId, smPos, svg, trans, u, units, val, vb, vbScale, vbox, xml, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _m, _ref, _ref1, _ref2, _ref3;\n  if (layers == null) {\n    layers = [];\n  }\n  copper = null;\n  mask = null;\n  silk = null;\n  paste = null;\n  edge = null;\n  drill = [];\n  attr = {};\n  defs = [];\n  draw = [];\n  bbox = [Infinity, Infinity, -Infinity, -Infinity];\n  edgeBbox = null;\n  units = 'px';\n  scale = null;\n  addVboxToBbox = function(v) {\n    var xMax, yMax;\n    xMax = v[2] + v[0];\n    yMax = v[3] + v[1];\n    if (v[0] < bbox[0]) {\n      bbox[0] = v[0];\n    }\n    if (v[1] < bbox[1]) {\n      bbox[1] = v[1];\n    }\n    if (xMax > bbox[2]) {\n      bbox[2] = xMax;\n    }\n    if (yMax > bbox[3]) {\n      return bbox[3] = yMax;\n    }\n  };\n  getVboxFromBbox = function(bb) {\n    return [bb[0], bb[1], bb[2] - bb[0], bb[3] - bb[1]];\n  };\n  for (_i = 0, _len = layers.length; _i < _len; _i++) {\n    layer = layers[_i];\n    ly = layer.type;\n    xml = layer.svgObj;\n    if (xml.svg == null) {\n      continue;\n    }\n    addVboxToBbox(xml.svg.viewBox);\n    u = (_ref = xml.svg.width.match(/(in)|(mm)/)) != null ? _ref[0] : void 0;\n    if (units === 'px') {\n      units = u;\n    } else if (u !== units) {\n      return {};\n    }\n    vbScale = parseFloat(xml.svg.width) / xml.svg.viewBox[2];\n    if (scale == null) {\n      scale = vbScale;\n    } else if (Math.abs(vbScale - scale) > 0.0000001) {\n      return {};\n    }\n    _ref1 = xml.svg;\n    for (key in _ref1) {\n      val = _ref1[key];\n      if ((attr[key] == null) && key !== '_') {\n        attr[key] = val;\n      }\n    }\n    layerId = \"\" + name + \"-\" + ly + \"_\" + (uniqueId());\n    _ref2 = xml.svg._;\n    for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {\n      node = _ref2[_j];\n      if (node.defs != null) {\n        _ref3 = node.defs._;\n        for (_k = 0, _len2 = _ref3.length; _k < _len2; _k++) {\n          d = _ref3[_k];\n          defs.push(d);\n        }\n      } else if (node.g != null) {\n        delete node.g.transform;\n        node.g.id = layerId;\n        defs.push(node);\n      }\n    }\n    if (reCOPPER.test(ly)) {\n      copper = layerId;\n    } else if (reMASK.test(ly)) {\n      mask = layerId;\n    } else if (reSILK.test(ly)) {\n      silk = layerId;\n    } else if (rePASTE.test(ly)) {\n      paste = layerId;\n    } else if (reDRILL.test(ly)) {\n      drill.push(layerId);\n    } else if (reEDGE.test(ly)) {\n      edge = layerId;\n      group = defs[defs.length - 1].g._;\n      for (_l = 0, _len3 = group.length; _l < _len3; _l++) {\n        n = group[_l];\n        if ((n.path != null) && n.path['stroke-width']) {\n          path = n.path;\n          break;\n        }\n      }\n      newPathData = [];\n      try {\n        newPathData = boardOutline(path.d);\n      } catch (_error) {\n        e = _error;\n      }\n      if (newPathData.length) {\n        oldSW = path['stroke-width'];\n        path['stroke-width'] = 0;\n        path.fill = '#fff';\n        path['fill-rule'] = 'evenodd';\n        path.d = newPathData;\n        vb = xml.svg.viewBox;\n        vb[0] += oldSW / 2;\n        vb[1] += oldSW / 2;\n        vb[2] -= oldSW;\n        vb[3] -= oldSW;\n        edgeBbox = [vb[0], vb[1], vb[2] + vb[0], vb[3] + vb[1]];\n      }\n    }\n    xml = null;\n  }\n  if (copper == null) {\n    return {};\n  }\n  if (edgeBbox != null) {\n    bbox = edgeBbox;\n  }\n  vbox = getVboxFromBbox(bbox);\n  bboxRect = function(cls, fill) {\n    if (cls == null) {\n      cls = 'Board--cover';\n    }\n    if (fill == null) {\n      fill = 'currentColor';\n    }\n    return {\n      rect: {\n        \"class\": cls,\n        fill: fill,\n        x: vbox[0],\n        y: vbox[1],\n        width: vbox[2],\n        height: vbox[3]\n      }\n    };\n  };\n  draw.push(bboxRect('Board--board'));\n  draw.push({\n    use: {\n      \"class\": 'Board--cu',\n      'xlink:href': \"#\" + copper\n    }\n  });\n  if (mask != null) {\n    cuFinishId = \"\" + name + \"-sm_\" + (uniqueId());\n    defs.push({\n      mask: {\n        id: cuFinishId,\n        color: '#fff',\n        _: [\n          {\n            use: {\n              'xlink:href': \"#\" + copper\n            }\n          }\n        ]\n      }\n    });\n    draw.push({\n      use: {\n        \"class\": 'Board--cf',\n        mask: \"url(#\" + cuFinishId + \")\",\n        'xlink:href': \"#\" + mask\n      }\n    });\n    smId = \"\" + name + \"-sm_\" + (uniqueId());\n    defs.push({\n      mask: {\n        id: smId,\n        color: '#000',\n        _: [\n          bboxRect(null, '#fff'), {\n            use: {\n              'xlink:href': \"#\" + mask\n            }\n          }\n        ]\n      }\n    });\n    smPos = {\n      g: {\n        mask: \"url(#\" + smId + \")\",\n        _: [bboxRect('Board--sm')]\n      }\n    };\n    if (silk != null) {\n      smPos.g._.push({\n        use: {\n          \"class\": 'Board--ss',\n          'xlink:href': \"#\" + silk\n        }\n      });\n    }\n    draw.push(smPos);\n  }\n  if (paste != null) {\n    draw.push({\n      use: {\n        \"class\": 'Board--sp',\n        'xlink:href': \"#\" + paste\n      }\n    });\n  }\n  if ((edge != null) && (edgeBbox == null)) {\n    draw.push({\n      use: {\n        \"class\": 'Board--out',\n        'xlink:href': \"#\" + edge\n      }\n    });\n  }\n  mechId = null;\n  if (drill.length || (edgeBbox != null)) {\n    mechId = \"\" + name + \"-mech_\" + (uniqueId());\n    mechMask = {\n      mask: {\n        id: mechId,\n        color: '#000',\n        _: []\n      }\n    };\n    mechMask.mask._.push(edgeBbox != null ? {\n      use: {\n        'xlink:href': \"#\" + edge\n      }\n    } : bboxRect(null, '#fff'));\n    for (_m = 0, _len4 = drill.length; _m < _len4; _m++) {\n      d = drill[_m];\n      mechMask.mask._.push({\n        use: {\n          'xlink:href': \"#\" + d\n        }\n      });\n    }\n    defs.push(mechMask);\n  }\n  if (name === 'bottom') {\n    trans = \"translate(\" + (bbox[2] + bbox[0]) + \",\" + (bbox[3] + bbox[1]) + \") scale(-1,-1)\";\n  } else {\n    trans = \"translate(0,\" + (bbox[3] + bbox[1]) + \") scale(1,-1)\";\n  }\n  draw = {\n    g: {\n      transform: trans,\n      _: draw\n    }\n  };\n  if (mechId) {\n    draw.g.mask = \"url(#\" + mechId + \")\";\n  }\n  svg = attr;\n  svg[\"class\"] = 'Board';\n  svg.viewBox = getVboxFromBbox(bbox);\n  svg.width = \"\" + (svg.viewBox[2] * scale) + units;\n  svg.height = \"\" + (svg.viewBox[3] * scale) + units;\n  svg._ = [];\n  if (defs.length) {\n    svg._.push({\n      defs: {\n        _: defs\n      }\n    });\n  }\n  if (draw.g._.length) {\n    svg._.push(draw);\n  }\n  return {\n    svg: svg\n  };\n};\n\n\n\n},{\"./build-board-outline.coffee\":102}],104:[function(require,module,exports){\nvar build;\n\nbuild = require('../build-board.coffee');\n\nself.addEventListener('message', function(e) {\n  var boardObj, layers, name;\n  name = e.data.name;\n  layers = e.data.layers;\n  boardObj = build(name, layers);\n  return self.postMessage({\n    name: name,\n    svgObj: boardObj\n  });\n}, false);\n\n\n\n},{\"../build-board.coffee\":103}]},{},[104])"],{type:"text/javascript"}))),d=function(a){function b(){return b.__super__.constructor.apply(this,arguments)
}return h(b,a),b.prototype.model=c,b.prototype.initialize=function(){return this.attachBuilderHandler(),this.on("buildNeeded",this.buildBoard),b.__super__.initialize.call(this)},b.prototype.buildBoard=function(a){return f.postMessage({name:a.get("name"),layers:a.get("boardLayers")})},b.prototype.attachBuilderHandler=function(){var a,b;return b=this,a=function(a){return b.convert(a.data.name,a.data.svgObj)},f.addEventListener("message",a,!1)},b}(e),b.exports=d},{"../models/board":"/Users/mc/projects/svgerber/src/models/board.coffee","./renders":"/Users/mc/projects/svgerber/src/collections/renders.coffee"}],"/Users/mc/projects/svgerber/src/collections/layers.coffee":[function(a,b){var c,d,e,f={}.hasOwnProperty,g=function(a,b){function c(){this.constructor=a}for(var d in b)f.call(b,d)&&(a[d]=b[d]);return c.prototype=b.prototype,a.prototype=new c,a.__super__=b.prototype,a};c=a("../models/layer"),e=a("./renders"),d=function(a){function b(){return b.__super__.constructor.apply(this,arguments)}return g(b,a),b.prototype.model=c,b.prototype.initialize=function(){return this.on("change:type",this.validateLayers),this.on("change:gerber",function(a){var b;return b=a.get("gerber"),b?this.convert(a.get("name"),b):void 0}),b.__super__.initialize.call(this)},b.prototype.validateLayers=function(){var a;return a=!0,this.forEach(function(b){return b.isValid()?b.trigger("valid"):a=!1,!0}),a},b}(e),b.exports=d},{"../models/layer":"/Users/mc/projects/svgerber/src/models/layer.coffee","./renders":"/Users/mc/projects/svgerber/src/collections/renders.coffee"}],"/Users/mc/projects/svgerber/src/collections/renders.coffee":[function(a,b){var c,d,e,f={}.hasOwnProperty,g=function(a,b){function c(){this.constructor=a}for(var d in b)f.call(b,d)&&(a[d]=b[d]);return c.prototype=b.prototype,a.prototype=new c,a.__super__=b.prototype,a};d=new Worker(window.URL.createObjectURL(new Blob(["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error(\"Cannot find module '\"+o+\"'\")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n(function() {\n  var getSvgCoord;\n\n  getSvgCoord = require('./svg-coord').get;\n\n  module.exports = function(coord, format) {\n    var key, parse, result, val, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7;\n    if (coord == null) {\n      return {};\n    }\n    if (!((format.zero != null) && (format.places != null))) {\n      throw new Error('format undefined');\n    }\n    parse = {};\n    result = {};\n    parse.x = (_ref = coord.match(/X[+-]?[\\d\\.]+/)) != null ? (_ref1 = _ref[0]) != null ? _ref1.slice(1) : void 0 : void 0;\n    parse.y = (_ref2 = coord.match(/Y[+-]?[\\d\\.]+/)) != null ? (_ref3 = _ref2[0]) != null ? _ref3.slice(1) : void 0 : void 0;\n    parse.i = (_ref4 = coord.match(/I[+-]?[\\d\\.]+/)) != null ? (_ref5 = _ref4[0]) != null ? _ref5.slice(1) : void 0 : void 0;\n    parse.j = (_ref6 = coord.match(/J[+-]?[\\d\\.]+/)) != null ? (_ref7 = _ref6[0]) != null ? _ref7.slice(1) : void 0 : void 0;\n    for (key in parse) {\n      val = parse[key];\n      if (val != null) {\n        result[key] = getSvgCoord(val, format);\n      }\n    }\n    return result;\n  };\n\n}).call(this);\n\n},{\"./svg-coord\":14}],2:[function(require,module,exports){\n(function() {\n  var ABS_COMMAND, DrillParser, INCH_COMMAND, INC_COMMAND, METRIC_COMMAND, PLACES_BACKUP, Parser, ZERO_BACKUP, getSvgCoord, parseCoord, reCOORD,\n    __hasProp = {}.hasOwnProperty,\n    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\n  Parser = require('./parser');\n\n  parseCoord = require('./coord-parser');\n\n  getSvgCoord = require('./svg-coord').get;\n\n  INCH_COMMAND = {\n    'FMAT,1': 'M70',\n    'FMAT,2': 'M72'\n  };\n\n  METRIC_COMMAND = 'M71';\n\n  ABS_COMMAND = 'G90';\n\n  INC_COMMAND = 'G91';\n\n  reCOORD = /[XY]{1,2}/;\n\n  ZERO_BACKUP = 'L';\n\n  PLACES_BACKUP = [2, 4];\n\n  DrillParser = (function(_super) {\n    __extends(DrillParser, _super);\n\n    function DrillParser() {\n      this.fmat = 'FMAT,2';\n      DrillParser.__super__.constructor.call(this, arguments[0]);\n    }\n\n    DrillParser.prototype.parseCommand = function(block) {\n      var code, command, dia, k, v, _base, _base1, _base2, _base3, _ref, _ref1, _ref2;\n      command = {};\n      if (block[0] === ';') {\n        return command;\n      }\n      if (block === 'FMAT,1') {\n        this.fmat = block;\n      } else if (block === 'M30' || block === 'M00') {\n        command.set = {\n          done: true\n        };\n      } else if (block === INCH_COMMAND[this.fmat] || block.match(/INCH/)) {\n        if ((_base = this.format).places == null) {\n          _base.places = [2, 4];\n        }\n        command.set = {\n          units: 'in'\n        };\n      } else if (block === METRIC_COMMAND || block.match(/METRIC/)) {\n        if ((_base1 = this.format).places == null) {\n          _base1.places = [3, 3];\n        }\n        command.set = {\n          units: 'mm'\n        };\n      } else if (block === ABS_COMMAND) {\n        command.set = {\n          notation: 'A'\n        };\n      } else if (block === INC_COMMAND) {\n        command.set = {\n          notation: 'I'\n        };\n      } else if ((code = (_ref = block.match(/T\\d+/)) != null ? _ref[0] : void 0)) {\n        while (code[1] === '0') {\n          code = code[0] + code.slice(2);\n        }\n        if ((dia = (_ref1 = block.match(/C[\\d\\.]+(?=.*$)/)) != null ? _ref1[0] : void 0)) {\n          dia = dia.slice(1);\n          command.tool = {};\n          command.tool[code] = {\n            dia: getSvgCoord(dia, {\n              places: this.format.places\n            })\n          };\n        } else {\n          command.set = {\n            currentTool: code\n          };\n        }\n      }\n      if (block.match(/TZ/)) {\n        if ((_base2 = this.format).zero == null) {\n          _base2.zero = 'L';\n        }\n      } else if (block.match(/LZ/)) {\n        if ((_base3 = this.format).zero == null) {\n          _base3.zero = 'T';\n        }\n      }\n      if (block.match(reCOORD)) {\n        command.op = {\n          \"do\": 'flash'\n        };\n        if (this.format.zero == null) {\n          console.warn('no drill file zero suppression specified. assuming leading zero suppression (same as no zero suppression)');\n          this.format.zero = ZERO_BACKUP;\n        }\n        if (this.format.places == null) {\n          console.warn('no drill file units specified; assuming 2:4 inches format');\n          this.format.places = PLACES_BACKUP;\n        }\n        _ref2 = parseCoord(block, this.format);\n        for (k in _ref2) {\n          v = _ref2[k];\n          command.op[k] = v;\n        }\n      }\n      return command;\n    };\n\n    return DrillParser;\n\n  })(Parser);\n\n  module.exports = DrillParser;\n\n}).call(this);\n\n},{\"./coord-parser\":1,\"./parser\":11,\"./svg-coord\":14}],3:[function(require,module,exports){\n(function() {\n  var DrillReader;\n\n  DrillReader = (function() {\n    function DrillReader(drillFile) {\n      this.line = 0;\n      this.blocks = drillFile.split(/\\r?\\n/);\n    }\n\n    DrillReader.prototype.nextBlock = function() {\n      if (this.line < this.blocks.length) {\n        return this.blocks[++this.line - 1];\n      } else {\n        return false;\n      }\n    };\n\n    return DrillReader;\n\n  })();\n\n  module.exports = DrillReader;\n\n}).call(this);\n\n},{}],4:[function(require,module,exports){\n(function() {\n  var GerberParser, Parser, getSvgCoord, parseCoord, reCOORD,\n    __hasProp = {}.hasOwnProperty,\n    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\n  Parser = require('./parser');\n\n  parseCoord = require('./coord-parser');\n\n  getSvgCoord = require('./svg-coord').get;\n\n  reCOORD = /([XYIJ][+-]?\\d+){1,4}/g;\n\n  GerberParser = (function(_super) {\n    __extends(GerberParser, _super);\n\n    function GerberParser() {\n      return GerberParser.__super__.constructor.apply(this, arguments);\n    }\n\n    GerberParser.prototype.parseFormat = function(p, c) {\n      var nota, places, zero, _base, _base1;\n      zero = p[2] === 'L' || p[2] === 'T' ? p[2] : null;\n      nota = p[3] === 'A' || p[3] === 'I' ? p[3] : null;\n      if (p[4] === 'X' && p[7] === 'Y' && p.slice(5, 7) === p.slice(8, 10) && p[5] < 8 && p[6] < 8) {\n        places = [+p[5], +p[6]];\n      }\n      if ((places == null) || (nota == null) || (zero == null)) {\n        throw new Error('invalid format specification');\n      }\n      if ((_base = this.format).zero == null) {\n        _base.zero = zero;\n      }\n      if ((_base1 = this.format).places == null) {\n        _base1.places = places;\n      }\n      if (c.set == null) {\n        c.set = {};\n      }\n      return c.set.notation = nota;\n    };\n\n    GerberParser.prototype.parseToolDef = function(p, c) {\n      var code, hole, m, mods, shape, _ref, _ref1;\n      if (c.tool == null) {\n        c.tool = {};\n      }\n      code = (_ref = p.match(/^ADD\\d{2,}/)) != null ? _ref[0].slice(2) : void 0;\n      _ref1 = p.slice(2 + code.length).split(','), shape = _ref1[0], mods = _ref1[1];\n      mods = mods != null ? mods.split('X') : void 0;\n      while (code[1] === '0') {\n        code = code[0] + code.slice(2);\n      }\n      switch (shape) {\n        case 'C':\n          if (mods.length > 2) {\n            hole = {\n              width: getSvgCoord(mods[1], {\n                places: this.format.places\n              }),\n              height: getSvgCoord(mods[2], {\n                places: this.format.places\n              })\n            };\n          } else if (mods.length > 1) {\n            hole = {\n              dia: getSvgCoord(mods[1], {\n                places: this.format.places\n              })\n            };\n          }\n          c.tool[code] = {\n            dia: getSvgCoord(mods[0], {\n              places: this.format.places\n            })\n          };\n          if (hole != null) {\n            return c.tool[code].hole = hole;\n          }\n          break;\n        case 'R':\n        case 'O':\n          if (mods.length > 3) {\n            hole = {\n              width: getSvgCoord(mods[2], {\n                places: this.format.places\n              }),\n              height: getSvgCoord(mods[3], {\n                places: this.format.places\n              })\n            };\n          } else if (mods.length > 2) {\n            hole = {\n              dia: getSvgCoord(mods[2], {\n                places: this.format.places\n              })\n            };\n          }\n          c.tool[code] = {\n            width: getSvgCoord(mods[0], {\n              places: this.format.places\n            }),\n            height: getSvgCoord(mods[1], {\n              places: this.format.places\n            })\n          };\n          if (shape === 'O') {\n            c.tool[code].obround = true;\n          }\n          if (hole != null) {\n            return c.tool[code].hole = hole;\n          }\n          break;\n        case 'P':\n          if (mods.length > 4) {\n            hole = {\n              width: getSvgCoord(mods[3], {\n                places: this.format.places\n              }),\n              height: getSvgCoord(mods[4], {\n                places: this.format.places\n              })\n            };\n          } else if (mods.length > 3) {\n            hole = {\n              dia: getSvgCoord(mods[3], {\n                places: this.format.places\n              })\n            };\n          }\n          c.tool[code] = {\n            dia: getSvgCoord(mods[0], {\n              places: this.format.places\n            }),\n            verticies: +mods[1]\n          };\n          if (mods.length > 2) {\n            c.tool[code].degrees = +mods[2];\n          }\n          if (hole != null) {\n            return c.tool[code].hole = hole;\n          }\n          break;\n        default:\n          mods = (function() {\n            var _i, _len, _ref2, _results;\n            _ref2 = mods != null ? mods : [];\n            _results = [];\n            for (_i = 0, _len = _ref2.length; _i < _len; _i++) {\n              m = _ref2[_i];\n              _results.push(+m);\n            }\n            return _results;\n          })();\n          return c.tool[code] = {\n            macro: shape,\n            mods: mods\n          };\n      }\n    };\n\n    GerberParser.prototype.parseCommand = function(block) {\n      var axis, c, code, coord, i, j, m, op, p, param, tool, u, val, x, y, _i, _len, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9;\n      if (block == null) {\n        block = {};\n      }\n      c = {};\n      if (param = block.param) {\n        for (_i = 0, _len = param.length; _i < _len; _i++) {\n          p = param[_i];\n          switch (code = p.slice(0, 2)) {\n            case 'FS':\n              this.parseFormat(p, c);\n              break;\n            case 'MO':\n              u = p.slice(2, 4);\n              if (c.set == null) {\n                c.set = {};\n              }\n              if (u === 'IN') {\n                c.set.units = 'in';\n              } else if (u === 'MM') {\n                c.set.units = 'mm';\n              } else {\n                throw new Error(\"\" + p + \" is an invalid units setting\");\n              }\n              break;\n            case 'AD':\n              this.parseToolDef(p, c);\n              break;\n            case 'AM':\n              return {\n                macro: param\n              };\n            case 'LP':\n              if (c[\"new\"] == null) {\n                c[\"new\"] = {};\n              }\n              if (p[2] === 'D' || p[2] === 'C') {\n                c[\"new\"].layer = p[2];\n              }\n              if (c[\"new\"].layer == null) {\n                throw new Error('invalid level polarity');\n              }\n              break;\n            case 'SR':\n              if (c[\"new\"] == null) {\n                c[\"new\"] = {};\n              }\n              x = (_ref = (_ref1 = p.match(/X[+-]?[\\d\\.]+/)) != null ? _ref1[0].slice(1) : void 0) != null ? _ref : 1;\n              y = (_ref2 = (_ref3 = p.match(/Y[+-]?[\\d\\.]+/)) != null ? _ref3[0].slice(1) : void 0) != null ? _ref2 : 1;\n              i = (_ref4 = p.match(/I[+-]?[\\d\\.]+/)) != null ? _ref4[0].slice(1) : void 0;\n              j = (_ref5 = p.match(/J[+-]?[\\d\\.]+/)) != null ? _ref5[0].slice(1) : void 0;\n              if ((x < 1 || y < 1) || (x > 1 && ((i == null) || i < 0)) || (y > 1 && ((j == null) || j < 0))) {\n                throw new Error('invalid step repeat');\n              }\n              c[\"new\"].sr = {\n                x: +x,\n                y: +y\n              };\n              if (i != null) {\n                c[\"new\"].sr.i = getSvgCoord(i, {\n                  places: this.format.places\n                });\n              }\n              if (j != null) {\n                c[\"new\"].sr.j = getSvgCoord(j, {\n                  places: this.format.places\n                });\n              }\n          }\n        }\n      } else if (block = block.block) {\n        if (block === 'M02') {\n          return {\n            set: {\n              done: true\n            }\n          };\n        } else if (block[0] === 'G') {\n          switch (code = (_ref6 = block.slice(1).match(/^\\d{1,2}/)) != null ? _ref6[0] : void 0) {\n            case '4':\n            case '04':\n              return {};\n            case '1':\n            case '01':\n            case '2':\n            case '02':\n            case '3':\n            case '03':\n              code = code[code.length - 1];\n              m = code === '1' ? 'i' : code === '2' ? 'cw' : 'ccw';\n              c.set = {\n                mode: m\n              };\n              break;\n            case '36':\n            case '37':\n              c.set = {\n                region: code === '36'\n              };\n              break;\n            case '70':\n            case '71':\n              c.set = {\n                backupUnits: code === '70' ? 'in' : 'mm'\n              };\n              break;\n            case '74':\n            case '75':\n              c.set = {\n                quad: code === '74' ? 's' : 'm'\n              };\n          }\n        }\n        coord = parseCoord((_ref7 = block.match(reCOORD)) != null ? _ref7[0] : void 0, this.format);\n        if (op = ((_ref8 = block.match(/D0?[123]$/)) != null ? _ref8[0] : void 0) || Object.keys(coord).length) {\n          if (op != null) {\n            op = op[op.length - 1];\n          }\n          op = (function() {\n            switch (op) {\n              case '1':\n                return 'int';\n              case '2':\n                return 'move';\n              case '3':\n                return 'flash';\n              default:\n                return 'last';\n            }\n          })();\n          c.op = {\n            \"do\": op\n          };\n          for (axis in coord) {\n            val = coord[axis];\n            c.op[axis] = val;\n          }\n        } else if (tool = (_ref9 = block.match(/D\\d+$/)) != null ? _ref9[0] : void 0) {\n          c.set = {\n            currentTool: tool\n          };\n        }\n      }\n      return c;\n    };\n\n    return GerberParser;\n\n  })(Parser);\n\n  module.exports = GerberParser;\n\n}).call(this);\n\n},{\"./coord-parser\":1,\"./parser\":11,\"./svg-coord\":14}],5:[function(require,module,exports){\n(function() {\n  var GerberReader;\n\n  GerberReader = (function() {\n    function GerberReader(gerberFile) {\n      this.gerberFile = gerberFile != null ? gerberFile : '';\n      this.line = 0;\n      this.charIndex = 0;\n      this.end = this.gerberFile.length;\n    }\n\n    GerberReader.prototype.nextBlock = function() {\n      var char, current, parameter;\n      if (this.index >= this.end) {\n        return false;\n      }\n      current = '';\n      parameter = false;\n      if (this.line === 0) {\n        this.line++;\n      }\n      while (!(this.charIndex >= this.end)) {\n        char = this.gerberFile[this.charIndex++];\n        if (char === '%') {\n          if (!parameter) {\n            parameter = [];\n          } else {\n            return {\n              param: parameter\n            };\n          }\n        } else if (char === '*') {\n          if (parameter) {\n            parameter.push(current);\n            current = '';\n          } else {\n            return {\n              block: current\n            };\n          }\n        } else if (char === '\\n') {\n          this.line++;\n        } else if ((' ' <= char && char <= '~')) {\n          current += char;\n        }\n      }\n      return false;\n    };\n\n    GerberReader.prototype.getLine = function() {\n      return this.line;\n    };\n\n    return GerberReader;\n\n  })();\n\n  module.exports = GerberReader;\n\n}).call(this);\n\n},{}],6:[function(require,module,exports){\n(function (global){\n(function() {\n  var DEFAULT_OPTS, DrillParser, DrillReader, GerberParser, GerberReader, Plotter, builder, coordFactor;\n\n  builder = require('./obj-to-xml');\n\n  Plotter = require('./plotter');\n\n  DrillReader = require('./drill-reader');\n\n  DrillParser = require('./drill-parser');\n\n  GerberReader = require('./gerber-reader');\n\n  GerberParser = require('./gerber-parser');\n\n  coordFactor = require('./svg-coord').factor;\n\n  DEFAULT_OPTS = {\n    drill: false,\n    pretty: false,\n    object: false,\n    warnArr: null,\n    places: null,\n    zero: null,\n    notation: null,\n    units: null\n  };\n\n  module.exports = function(file, options) {\n    var a, error, height, key, oldWarn, opts, p, parser, parserOpts, plotterOpts, reader, root, val, width, xml, xmlObject, _ref;\n    if (options == null) {\n      options = {};\n    }\n    opts = {};\n    for (key in DEFAULT_OPTS) {\n      val = DEFAULT_OPTS[key];\n      opts[key] = val;\n    }\n    for (key in options) {\n      val = options[key];\n      opts[key] = val;\n    }\n    if (typeof file === 'object') {\n      if (file.svg != null) {\n        return builder(file, {\n          pretty: opts.pretty\n        });\n      } else {\n        throw new Error('non SVG object cannot be converted to an SVG string');\n      }\n    }\n    parserOpts = null;\n    if ((opts.places != null) || (opts.zero != null)) {\n      parserOpts = {\n        places: opts.places,\n        zero: opts.zero\n      };\n    }\n    if (opts.drill) {\n      reader = new DrillReader(file);\n      parser = new DrillParser(parserOpts);\n    } else {\n      reader = new GerberReader(file);\n      parser = new GerberParser(parserOpts);\n    }\n    plotterOpts = null;\n    if ((opts.notation != null) || (opts.units != null)) {\n      plotterOpts = {\n        notation: opts.notation,\n        units: opts.units\n      };\n    }\n    p = new Plotter(reader, parser, plotterOpts);\n    oldWarn = null;\n    root = null;\n    if (Array.isArray(opts.warnArr)) {\n      root = typeof window !== \"undefined\" && window !== null ? window : global;\n      if (root.console == null) {\n        root.console = {};\n      }\n      oldWarn = root.console.warn;\n      root.console.warn = function(chunk) {\n        return opts.warnArr.push(chunk.toString());\n      };\n    }\n    try {\n      xmlObject = p.plot();\n    } catch (_error) {\n      error = _error;\n      throw new Error(\"Error at line \" + p.reader.line + \" - \" + error.message);\n    } finally {\n      if ((oldWarn != null) && (root != null)) {\n        root.console.warn = oldWarn;\n      }\n    }\n    if (!(p.bbox.xMin >= p.bbox.xMax)) {\n      width = p.bbox.xMax - p.bbox.xMin;\n    } else {\n      p.bbox.xMin = 0;\n      p.bbox.xMax = 0;\n      width = 0;\n    }\n    if (!(p.bbox.yMin >= p.bbox.yMax)) {\n      height = p.bbox.yMax - p.bbox.yMin;\n    } else {\n      p.bbox.yMin = 0;\n      p.bbox.yMax = 0;\n      height = 0;\n    }\n    xml = {\n      svg: {\n        xmlns: 'http://www.w3.org/2000/svg',\n        version: '1.1',\n        'xmlns:xlink': 'http://www.w3.org/1999/xlink',\n        width: \"\" + (width / coordFactor) + p.units,\n        height: \"\" + (height / coordFactor) + p.units,\n        viewBox: [p.bbox.xMin, p.bbox.yMin, width, height],\n        _: []\n      }\n    };\n    _ref = p.attr;\n    for (a in _ref) {\n      val = _ref[a];\n      xml.svg[a] = val;\n    }\n    if (p.defs.length) {\n      xml.svg._.push({\n        defs: {\n          _: p.defs\n        }\n      });\n    }\n    if (p.group.g._.length) {\n      xml.svg._.push(p.group);\n    }\n    if (!opts.object) {\n      return builder(xml, {\n        pretty: opts.pretty\n      });\n    } else {\n      return xml;\n    }\n  };\n\n}).call(this);\n\n}).call(this,typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"./drill-parser\":2,\"./drill-reader\":3,\"./gerber-parser\":4,\"./gerber-reader\":5,\"./obj-to-xml\":9,\"./plotter\":12,\"./svg-coord\":14}],7:[function(require,module,exports){\n(function() {\n  var NUMBER, OPERATOR, TOKEN, isNumber, parse, tokenize;\n\n  OPERATOR = /[\\+\\-\\/xX\\(\\)]/;\n\n  NUMBER = /[\\$\\d\\.]+/;\n\n  TOKEN = new RegExp(\"(\" + OPERATOR.source + \")|(\" + NUMBER.source + \")\", 'g');\n\n  tokenize = function(arith) {\n    var results;\n    return results = arith.match(TOKEN);\n  };\n\n  isNumber = function(token) {\n    return NUMBER.test(token);\n  };\n\n  parse = function(arith) {\n    var consume, index, parseExpression, parseMultiplication, parsePrimary, peek, tokens;\n    tokens = tokenize(arith);\n    index = 0;\n    peek = function() {\n      return tokens[index];\n    };\n    consume = function(t) {\n      if (t === peek()) {\n        return index++;\n      }\n    };\n    parsePrimary = function() {\n      var exp, t;\n      t = peek();\n      consume(t);\n      if (isNumber(t)) {\n        exp = {\n          type: 'n',\n          val: t\n        };\n      } else if (t === '(') {\n        exp = parseExpression();\n        if (peek() !== ')') {\n          throw new Error(\"expected ')'\");\n        } else {\n          consume(')');\n        }\n      } else {\n        throw new Error(\"\" + t + \" is unexpected in an arithmetic string\");\n      }\n      return exp;\n    };\n    parseMultiplication = function() {\n      var exp, rhs, t;\n      exp = parsePrimary();\n      t = peek();\n      while (t === 'x' || t === '/' || t === 'X') {\n        consume(t);\n        if (t === 'X') {\n          console.warn(\"Warning: uppercase 'X' as multiplication symbol is incorrect; macros should use lowercase 'x' to multiply\");\n          t = 'x';\n        }\n        rhs = parsePrimary();\n        exp = {\n          type: t,\n          left: exp,\n          right: rhs\n        };\n        t = peek();\n      }\n      return exp;\n    };\n    parseExpression = function() {\n      var exp, rhs, t;\n      exp = parseMultiplication();\n      t = peek();\n      while (t === '+' || t === '-') {\n        consume(t);\n        rhs = parseMultiplication();\n        exp = {\n          type: t,\n          left: exp,\n          right: rhs\n        };\n        t = peek();\n      }\n      return exp;\n    };\n    return parseExpression();\n  };\n\n  module.exports = {\n    tokenize: tokenize,\n    isNumber: isNumber,\n    parse: parse\n  };\n\n}).call(this);\n\n},{}],8:[function(require,module,exports){\n(function() {\n  var MacroTool, calc, getSvgCoord, shapes, unique;\n\n  shapes = require('./pad-shapes');\n\n  calc = require('./macro-calc');\n\n  unique = require('./unique-id');\n\n  getSvgCoord = require('./svg-coord').get;\n\n  MacroTool = (function() {\n    function MacroTool(blocks, numberFormat) {\n      this.modifiers = {};\n      this.name = blocks[0].slice(2);\n      this.blocks = blocks.slice(1);\n      this.shapes = [];\n      this.masks = [];\n      this.lastExposure = null;\n      this.bbox = [null, null, null, null];\n      this.format = {\n        places: numberFormat\n      };\n    }\n\n    MacroTool.prototype.run = function(tool, modifiers) {\n      var b, group, i, m, pad, padId, s, shape, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1, _ref2;\n      if (modifiers == null) {\n        modifiers = [];\n      }\n      this.lastExposure = null;\n      this.shapes = [];\n      this.masks = [];\n      this.bbox = [null, null, null, null];\n      this.modifiers = {};\n      for (i = _i = 0, _len = modifiers.length; _i < _len; i = ++_i) {\n        m = modifiers[i];\n        this.modifiers[\"$\" + (i + 1)] = m;\n      }\n      _ref = this.blocks;\n      for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {\n        b = _ref[_j];\n        this.runBlock(b);\n      }\n      padId = \"tool-\" + tool + \"-pad-\" + (unique());\n      pad = [];\n      _ref1 = this.masks;\n      for (_k = 0, _len2 = _ref1.length; _k < _len2; _k++) {\n        m = _ref1[_k];\n        pad.push(m);\n      }\n      if (this.shapes.length > 1) {\n        group = {\n          id: padId,\n          _: []\n        };\n        _ref2 = this.shapes;\n        for (_l = 0, _len3 = _ref2.length; _l < _len3; _l++) {\n          s = _ref2[_l];\n          group._.push(s);\n        }\n        pad = [\n          {\n            g: group\n          }\n        ];\n      } else if (this.shapes.length === 1) {\n        shape = Object.keys(this.shapes[0])[0];\n        this.shapes[0][shape].id = padId;\n        pad.push(this.shapes[0]);\n      }\n      return {\n        pad: pad,\n        padId: padId,\n        bbox: this.bbox,\n        trace: false\n      };\n    };\n\n    MacroTool.prototype.runBlock = function(block) {\n      var a, args, i, mod, val, _i, _len, _ref;\n      switch (block[0]) {\n        case '$':\n          mod = (_ref = block.match(/^\\$\\d+(?=\\=)/)) != null ? _ref[0] : void 0;\n          val = block.slice(1 + mod.length);\n          return this.modifiers[mod] = this.getNumber(val);\n        case '1':\n        case '2':\n        case '20':\n        case '21':\n        case '22':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n          args = block.split(',');\n          for (i = _i = 0, _len = args.length; _i < _len; i = ++_i) {\n            a = args[i];\n            args[i] = this.getNumber(a);\n          }\n          return this.primitive(args);\n        default:\n          if (block[0] !== '0') {\n            throw new Error(\"'\" + block + \"' unrecognized tool macro block\");\n          }\n      }\n    };\n\n    MacroTool.prototype.primitive = function(args) {\n      var group, i, key, m, mask, maskId, points, rot, rotation, s, shape, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _m, _n, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _results;\n      mask = false;\n      rotation = false;\n      shape = null;\n      switch (args[0]) {\n        case 1:\n          shape = shapes.circle({\n            dia: getSvgCoord(args[2], this.format),\n            cx: getSvgCoord(args[3], this.format),\n            cy: getSvgCoord(args[4], this.format)\n          });\n          if (args[1] === 0) {\n            mask = true;\n          } else {\n            this.addBbox(shape.bbox);\n          }\n          break;\n        case 2:\n        case 20:\n          shape = shapes.vector({\n            width: getSvgCoord(args[2], this.format),\n            x1: getSvgCoord(args[3], this.format),\n            y1: getSvgCoord(args[4], this.format),\n            x2: getSvgCoord(args[5], this.format),\n            y2: getSvgCoord(args[6], this.format)\n          });\n          if (args[7]) {\n            shape.shape.line.transform = \"rotate(\" + args[7] + \")\";\n          }\n          if (args[1] === 0) {\n            mask = true;\n          } else {\n            this.addBbox(shape.bbox, args[7]);\n          }\n          break;\n        case 21:\n          shape = shapes.rect({\n            cx: getSvgCoord(args[4], this.format),\n            cy: getSvgCoord(args[5], this.format),\n            width: getSvgCoord(args[2], this.format),\n            height: getSvgCoord(args[3], this.format)\n          });\n          if (args[6]) {\n            shape.shape.rect.transform = \"rotate(\" + args[6] + \")\";\n          }\n          if (args[1] === 0) {\n            mask = true;\n          } else {\n            this.addBbox(shape.bbox, args[6]);\n          }\n          break;\n        case 22:\n          shape = shapes.lowerLeftRect({\n            x: getSvgCoord(args[4], this.format),\n            y: getSvgCoord(args[5], this.format),\n            width: getSvgCoord(args[2], this.format),\n            height: getSvgCoord(args[3], this.format)\n          });\n          if (args[6]) {\n            shape.shape.rect.transform = \"rotate(\" + args[6] + \")\";\n          }\n          if (args[1] === 0) {\n            mask = true;\n          } else {\n            this.addBbox(shape.bbox, args[6]);\n          }\n          break;\n        case 4:\n          points = [];\n          for (i = _i = 3, _ref = 3 + 2 * args[2]; _i <= _ref; i = _i += 2) {\n            points.push([getSvgCoord(args[i], this.format), getSvgCoord(args[i + 1], this.format)]);\n          }\n          shape = shapes.outline({\n            points: points\n          });\n          if (rot = args[args.length - 1]) {\n            shape.shape.polygon.transform = \"rotate(\" + rot + \")\";\n          }\n          if (args[1] === 0) {\n            mask = true;\n          } else {\n            this.addBbox(shape.bbox, args[args.length - 1]);\n          }\n          break;\n        case 5:\n          if (args[6] !== 0 && (args[3] !== 0 || args[4] !== 0)) {\n            throw new RangeError('polygon center must be 0,0 if rotated in macro');\n          }\n          shape = shapes.polygon({\n            cx: getSvgCoord(args[3], this.format),\n            cy: getSvgCoord(args[4], this.format),\n            dia: getSvgCoord(args[5], this.format),\n            verticies: args[2],\n            degrees: args[6]\n          });\n          if (args[1] === 0) {\n            mask = true;\n          } else {\n            this.addBbox(shape.bbox);\n          }\n          break;\n        case 6:\n          if (args[9] !== 0 && (args[1] !== 0 || args[2] !== 0)) {\n            throw new RangeError('moir center must be 0,0 if rotated in macro');\n          }\n          shape = shapes.moire({\n            cx: getSvgCoord(args[1], this.format),\n            cy: getSvgCoord(args[2], this.format),\n            outerDia: getSvgCoord(args[3], this.format),\n            ringThx: getSvgCoord(args[4], this.format),\n            ringGap: getSvgCoord(args[5], this.format),\n            maxRings: args[6],\n            crossThx: getSvgCoord(args[7], this.format),\n            crossLength: getSvgCoord(args[8], this.format)\n          });\n          if (args[9]) {\n            _ref1 = shape.shape;\n            for (_j = 0, _len = _ref1.length; _j < _len; _j++) {\n              s = _ref1[_j];\n              if (s.line != null) {\n                s.line.transform = \"rotate(\" + args[9] + \")\";\n              }\n            }\n          }\n          this.addBbox(shape.bbox, args[9]);\n          break;\n        case 7:\n          if (args[9] !== 0 && (args[1] !== 0 || args[2] !== 0)) {\n            throw new RangeError('thermal center must be 0,0 if rotated in macro');\n          }\n          shape = shapes.thermal({\n            cx: getSvgCoord(args[1], this.format),\n            cy: getSvgCoord(args[2], this.format),\n            outerDia: getSvgCoord(args[3], this.format),\n            innerDia: getSvgCoord(args[4], this.format),\n            gap: getSvgCoord(args[5], this.format)\n          });\n          if (args[6]) {\n            _ref2 = shape.shape;\n            for (_k = 0, _len1 = _ref2.length; _k < _len1; _k++) {\n              s = _ref2[_k];\n              if (s.mask != null) {\n                _ref3 = s.mask._;\n                for (_l = 0, _len2 = _ref3.length; _l < _len2; _l++) {\n                  m = _ref3[_l];\n                  if (m.rect != null) {\n                    m.rect.transform = \"rotate(\" + args[6] + \")\";\n                  }\n                }\n              }\n            }\n          }\n          this.addBbox(shape.bbox, args[6]);\n          break;\n        default:\n          throw new Error(\"\" + args[0] + \" is not a valid primitive code\");\n      }\n      if (mask) {\n        for (key in shape.shape) {\n          shape.shape[key].fill = '#000';\n        }\n        if (this.lastExposure !== 0) {\n          this.lastExposure = 0;\n          maskId = \"macro-\" + this.name + \"-mask-\" + (unique());\n          m = {\n            mask: {\n              id: maskId\n            }\n          };\n          m.mask._ = [\n            {\n              rect: {\n                x: this.bbox[0],\n                y: this.bbox[1],\n                width: this.bbox[2] - this.bbox[0],\n                height: this.bbox[3] - this.bbox[1],\n                fill: '#fff'\n              }\n            }\n          ];\n          if (this.shapes.length === 1) {\n            for (key in this.shapes[0]) {\n              this.shapes[0][key].mask = \"url(#\" + maskId + \")\";\n            }\n          } else if (this.shapes.length > 1) {\n            group = {\n              mask: \"url(#\" + maskId + \")\",\n              _: []\n            };\n            _ref4 = this.shapes;\n            for (_m = 0, _len3 = _ref4.length; _m < _len3; _m++) {\n              s = _ref4[_m];\n              group._.push(s);\n            }\n            this.shapes = [\n              {\n                g: group\n              }\n            ];\n          }\n          this.masks.push(m);\n        }\n        return this.masks[this.masks.length - 1].mask._.push(shape.shape);\n      } else {\n        this.lastExposure = 1;\n        if (!Array.isArray(shape.shape)) {\n          return this.shapes.push(shape.shape);\n        } else {\n          _ref5 = shape.shape;\n          _results = [];\n          for (_n = 0, _len4 = _ref5.length; _n < _len4; _n++) {\n            s = _ref5[_n];\n            if (s.mask != null) {\n              _results.push(this.masks.push(s));\n            } else {\n              _results.push(this.shapes.push(s));\n            }\n          }\n          return _results;\n        }\n      }\n    };\n\n    MacroTool.prototype.addBbox = function(bbox, rotation) {\n      var b, c, p, points, s, x, y, _i, _len;\n      if (rotation == null) {\n        rotation = 0;\n      }\n      if (!rotation) {\n        if (this.bbox[0] === null || bbox[0] < this.bbox[0]) {\n          this.bbox[0] = bbox[0];\n        }\n        if (this.bbox[1] === null || bbox[1] < this.bbox[1]) {\n          this.bbox[1] = bbox[1];\n        }\n        if (this.bbox[2] === null || bbox[2] > this.bbox[2]) {\n          this.bbox[2] = bbox[2];\n        }\n        if (this.bbox[3] === null || bbox[3] > this.bbox[3]) {\n          return this.bbox[3] = bbox[3];\n        }\n      } else {\n        s = Math.sin(rotation * Math.PI / 180);\n        c = Math.cos(rotation * Math.PI / 180);\n        if (Math.abs(s) < 0.000000001) {\n          s = 0;\n        }\n        if (Math.abs(c) < 0.000000001) {\n          c = 0;\n        }\n        points = [[bbox[0], bbox[1]], [bbox[2], bbox[1]], [bbox[2], bbox[3]], [bbox[0], bbox[3]]];\n        for (_i = 0, _len = points.length; _i < _len; _i++) {\n          p = points[_i];\n          x = (p[0] * c) - (p[1] * s);\n          y = (p[0] * s) + (p[1] * c);\n          if (this.bbox[0] === null || x < this.bbox[0]) {\n            this.bbox[0] = x;\n          }\n          if (this.bbox[1] === null || y < this.bbox[1]) {\n            this.bbox[1] = y;\n          }\n          if (this.bbox[2] === null || x > this.bbox[2]) {\n            this.bbox[2] = x;\n          }\n          if (this.bbox[3] === null || y > this.bbox[3]) {\n            this.bbox[3] = y;\n          }\n        }\n        return this.bbox = (function() {\n          var _j, _len1, _ref, _results;\n          _ref = this.bbox;\n          _results = [];\n          for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {\n            b = _ref[_j];\n            _results.push(b === -0 ? 0 : b);\n          }\n          return _results;\n        }).call(this);\n      }\n    };\n\n    MacroTool.prototype.getNumber = function(s) {\n      if (s.match(/^[+-]?[\\d.]+$/)) {\n        return Number(s);\n      } else if (s.match(/^\\$\\d+$/)) {\n        return Number(this.modifiers[s]);\n      } else {\n        return this.evaluate(calc.parse(s));\n      }\n    };\n\n    MacroTool.prototype.evaluate = function(op) {\n      switch (op.type) {\n        case 'n':\n          return this.getNumber(op.val);\n        case '+':\n          return this.evaluate(op.left) + this.evaluate(op.right);\n        case '-':\n          return this.evaluate(op.left) - this.evaluate(op.right);\n        case 'x':\n          return this.evaluate(op.left) * this.evaluate(op.right);\n        case '/':\n          return this.evaluate(op.left) / this.evaluate(op.right);\n      }\n    };\n\n    return MacroTool;\n\n  })();\n\n  module.exports = MacroTool;\n\n}).call(this);\n\n},{\"./macro-calc\":7,\"./pad-shapes\":10,\"./svg-coord\":14,\"./unique-id\":15}],9:[function(require,module,exports){\n(function() {\n  var CKEY, DTAB, objToXml, repeat;\n\n  repeat = function(pattern, count) {\n    var result;\n    result = '';\n    if (count === 0) {\n      return '';\n    }\n    while (count > 1) {\n      if (count & 1) {\n        result += pattern;\n      }\n      count >>= 1;\n      pattern += pattern;\n    }\n    return result + pattern;\n  };\n\n  CKEY = '_';\n\n  DTAB = '  ';\n\n  objToXml = function(obj, op) {\n    var children, dec, decimals, elem, i, ind, key, nl, o, pre, tb, v, val, xml, _i, _len, _ref, _ref1, _ref2;\n    if (op == null) {\n      op = {};\n    }\n    pre = op.pretty;\n    ind = (_ref = op.indent) != null ? _ref : 0;\n    dec = (_ref1 = op.maxDec) != null ? _ref1 : false;\n    decimals = function(n) {\n      if (typeof n === 'number') {\n        return Number(n.toFixed(dec));\n      } else {\n        return n;\n      }\n    };\n    nl = pre ? '\\n' : '';\n    tb = nl ? (typeof pre === 'string' ? pre : DTAB) : '';\n    tb = repeat(tb, ind);\n    xml = '';\n    if (typeof obj === 'function') {\n      obj = obj();\n    }\n    if (Array.isArray(obj)) {\n      for (i = _i = 0, _len = obj.length; _i < _len; i = ++_i) {\n        o = obj[i];\n        xml += (i !== 0 ? nl : '') + (objToXml(o, op));\n      }\n    } else if (typeof obj === 'object') {\n      children = false;\n      elem = Object.keys(obj)[0];\n      if (elem != null) {\n        xml = \"\" + tb + \"<\" + elem;\n        if (typeof obj[elem] === 'function') {\n          obj[elem] = obj[elem]();\n        }\n        _ref2 = obj[elem];\n        for (key in _ref2) {\n          val = _ref2[key];\n          if (typeof val === 'function') {\n            val = val();\n          }\n          if (key === CKEY) {\n            children = val;\n          } else {\n            if (Array.isArray(val)) {\n              if (dec) {\n                val = (function() {\n                  var _j, _len1, _results;\n                  _results = [];\n                  for (_j = 0, _len1 = val.length; _j < _len1; _j++) {\n                    v = val[_j];\n                    _results.push(decimals(v));\n                  }\n                  return _results;\n                })();\n              }\n              val = val.join(' ');\n            }\n            if (dec) {\n              val = decimals(val);\n            }\n            xml += \" \" + key + \"=\\\"\" + val + \"\\\"\";\n          }\n        }\n        if (children) {\n          xml += '>' + nl + objToXml(children, {\n            pretty: pre,\n            indent: ind + 1\n          });\n        }\n        if (obj[elem]._ != null) {\n          xml += \"\" + nl + tb + \"</\" + elem + \">\";\n        } else {\n          xml += '/>';\n        }\n      }\n    } else {\n      xml += \"\" + obj + \" \";\n    }\n    return xml;\n  };\n\n  module.exports = objToXml;\n\n}).call(this);\n\n},{}],10:[function(require,module,exports){\n(function() {\n  var circle, lowerLeftRect, moire, outline, polygon, rect, thermal, unique, vector;\n\n  unique = require('./unique-id');\n\n  circle = function(p) {\n    var r;\n    if (p.dia == null) {\n      throw new Error('circle function requires diameter');\n    }\n    if (p.cx == null) {\n      throw new Error('circle function requires x center');\n    }\n    if (p.cy == null) {\n      throw new Error('circle function requires y center');\n    }\n    r = p.dia / 2;\n    return {\n      shape: {\n        circle: {\n          cx: p.cx,\n          cy: p.cy,\n          r: r\n        }\n      },\n      bbox: [p.cx - r, p.cy - r, p.cx + r, p.cy + r]\n    };\n  };\n\n  rect = function(p) {\n    var radius, rectangle, x, y;\n    if (p.width == null) {\n      throw new Error('rectangle requires width');\n    }\n    if (p.height == null) {\n      throw new Error('rectangle requires height');\n    }\n    if (p.cx == null) {\n      throw new Error('rectangle function requires x center');\n    }\n    if (p.cy == null) {\n      throw new Error('rectangle function requires y center');\n    }\n    x = p.cx - p.width / 2;\n    y = p.cy - p.height / 2;\n    rectangle = {\n      shape: {\n        rect: {\n          x: x,\n          y: y,\n          width: p.width,\n          height: p.height\n        }\n      },\n      bbox: [x, y, x + p.width, y + p.height]\n    };\n    if (p.obround) {\n      radius = 0.5 * Math.min(p.width, p.height);\n      rectangle.shape.rect.rx = radius;\n      rectangle.shape.rect.ry = radius;\n    }\n    return rectangle;\n  };\n\n  polygon = function(p) {\n    var i, points, r, rx, ry, start, step, theta, x, xMax, xMin, y, yMax, yMin, _i, _ref;\n    if (p.dia == null) {\n      throw new Error('polygon requires diameter');\n    }\n    if (p.verticies == null) {\n      throw new Error('polygon requires verticies');\n    }\n    if (p.cx == null) {\n      throw new Error('polygon function requires x center');\n    }\n    if (p.cy == null) {\n      throw new Error('polygon function requires y center');\n    }\n    start = p.degrees != null ? p.degrees * Math.PI / 180 : 0;\n    step = 2 * Math.PI / p.verticies;\n    r = p.dia / 2;\n    points = '';\n    xMin = null;\n    yMin = null;\n    xMax = null;\n    yMax = null;\n    for (i = _i = 0, _ref = p.verticies; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {\n      theta = start + (i * step);\n      rx = r * Math.cos(theta);\n      ry = r * Math.sin(theta);\n      if (Math.abs(rx) < 0.000000001) {\n        rx = 0;\n      }\n      if (Math.abs(ry) < 0.000000001) {\n        ry = 0;\n      }\n      x = p.cx + rx;\n      y = p.cy + ry;\n      if (x < xMin || xMin === null) {\n        xMin = x;\n      }\n      if (x > xMax || xMax === null) {\n        xMax = x;\n      }\n      if (y < yMin || yMin === null) {\n        yMin = y;\n      }\n      if (y > yMax || yMax === null) {\n        yMax = y;\n      }\n      points += \" \" + x + \",\" + y;\n    }\n    return {\n      shape: {\n        polygon: {\n          points: points.slice(1)\n        }\n      },\n      bbox: [xMin, yMin, xMax, yMax]\n    };\n  };\n\n  vector = function(p) {\n    var theta, xDelta, yDelta;\n    if (p.x1 == null) {\n      throw new Error('vector function requires start x');\n    }\n    if (p.y1 == null) {\n      throw new Error('vector function requires start y');\n    }\n    if (p.x2 == null) {\n      throw new Error('vector function requires end x');\n    }\n    if (p.y2 == null) {\n      throw new Error('vector function requires end y');\n    }\n    if (p.width == null) {\n      throw new Error('vector function requires width');\n    }\n    theta = Math.abs(Math.atan((p.y2 - p.y1) / (p.x2 - p.x1)));\n    xDelta = p.width / 2 * Math.sin(theta);\n    yDelta = p.width / 2 * Math.cos(theta);\n    if (xDelta < 0.0000001) {\n      xDelta = 0;\n    }\n    if (yDelta < 0.0000001) {\n      yDelta = 0;\n    }\n    return {\n      shape: {\n        line: {\n          x1: p.x1,\n          x2: p.x2,\n          y1: p.y1,\n          y2: p.y2,\n          'stroke-width': p.width,\n          'stroke-linecap': 'butt'\n        }\n      },\n      bbox: [(Math.min(p.x1, p.x2)) - xDelta, (Math.min(p.y1, p.y2)) - yDelta, (Math.max(p.x1, p.x2)) + xDelta, (Math.max(p.y1, p.y2)) + yDelta]\n    };\n  };\n\n  lowerLeftRect = function(p) {\n    if (p.width == null) {\n      throw new Error('lower left rect requires width');\n    }\n    if (p.height == null) {\n      throw new Error('lower left rect requires height');\n    }\n    if (p.x == null) {\n      throw new Error('lower left rectangle requires x');\n    }\n    if (p.y == null) {\n      throw new Error('lower left rectangle requires y');\n    }\n    return {\n      shape: {\n        rect: {\n          x: p.x,\n          y: p.y,\n          width: p.width,\n          height: p.height\n        }\n      },\n      bbox: [p.x, p.y, p.x + p.width, p.y + p.height]\n    };\n  };\n\n  outline = function(p) {\n    var point, pointString, x, xLast, xMax, xMin, y, yLast, yMax, yMin, _i, _len, _ref;\n    if (!(Array.isArray(p.points) && p.points.length > 1)) {\n      throw new Error('outline function requires points array');\n    }\n    xMin = null;\n    yMin = null;\n    xMax = null;\n    yMax = null;\n    pointString = '';\n    _ref = p.points;\n    for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n      point = _ref[_i];\n      if (!(Array.isArray(point) && point.length === 2)) {\n        throw new Error('outline function requires points array');\n      }\n      x = point[0];\n      y = point[1];\n      if (x < xMin || xMin === null) {\n        xMin = x;\n      }\n      if (x > xMax || xMax === null) {\n        xMax = x;\n      }\n      if (y < yMin || yMin === null) {\n        yMin = y;\n      }\n      if (y > yMax || yMax === null) {\n        yMax = y;\n      }\n      pointString += \" \" + x + \",\" + y;\n    }\n    xLast = p.points[p.points.length - 1][0];\n    yLast = p.points[p.points.length - 1][1];\n    if (!(xLast === p.points[0][0] && yLast === p.points[0][1])) {\n      throw new RangeError('last point must match first point of outline');\n    }\n    return {\n      shape: {\n        polygon: {\n          points: pointString.slice(1)\n        }\n      },\n      bbox: [xMin, yMin, xMax, yMax]\n    };\n  };\n\n  moire = function(p) {\n    var r, rings, shape;\n    if (p.cx == null) {\n      throw new Error('moir requires x center');\n    }\n    if (p.cy == null) {\n      throw new Error('moir requires y center');\n    }\n    if (p.outerDia == null) {\n      throw new Error('moir requires outer diameter');\n    }\n    if (p.ringThx == null) {\n      throw new Error('moir requires ring thickness');\n    }\n    if (p.ringGap == null) {\n      throw new Error('moir requires ring gap');\n    }\n    if (p.maxRings == null) {\n      throw new Error('moir requires max rings');\n    }\n    if (p.crossLength == null) {\n      throw new Error('moir requires crosshair length');\n    }\n    if (p.crossThx == null) {\n      throw new Error('moir requires crosshair thickness');\n    }\n    shape = [\n      {\n        line: {\n          x1: p.cx - p.crossLength / 2,\n          y1: 0,\n          x2: p.cx + p.crossLength / 2,\n          y2: 0,\n          'stroke-width': p.crossThx,\n          'stroke-linecap': 'butt'\n        }\n      }, {\n        line: {\n          x1: 0,\n          y1: p.cy - p.crossLength / 2,\n          x2: 0,\n          y2: p.cy + p.crossLength / 2,\n          'stroke-width': p.crossThx,\n          'stroke-linecap': 'butt'\n        }\n      }\n    ];\n    r = (p.outerDia - p.ringThx) / 2;\n    rings = 0;\n    while (r >= p.ringThx && rings < p.maxRings) {\n      shape.push({\n        circle: {\n          cx: p.cx,\n          cy: p.cy,\n          r: r,\n          fill: 'none',\n          'stroke-width': p.ringThx\n        }\n      });\n      rings++;\n      r -= p.ringThx + p.ringGap;\n    }\n    r += 0.5 * p.ringThx;\n    if (r > 0 && rings < p.maxRings) {\n      shape.push({\n        circle: {\n          cx: p.cx,\n          cy: p.cy,\n          r: r\n        }\n      });\n    }\n    return {\n      shape: shape,\n      bbox: [Math.min(p.cx - p.crossLength / 2, p.cx - p.outerDia / 2), Math.min(p.cy - p.crossLength / 2, p.cy - p.outerDia / 2), Math.max(p.cx + p.crossLength / 2, p.cx + p.outerDia / 2), Math.max(p.cy + p.crossLength / 2, p.cy + p.outerDia / 2)]\n    };\n  };\n\n  thermal = function(p) {\n    var halfGap, maskId, outerR, r, thx, xMax, xMin, yMax, yMin;\n    if (p.cx == null) {\n      throw new Error('thermal requires x center');\n    }\n    if (p.cy == null) {\n      throw new Error('thermal requires y center');\n    }\n    if (p.outerDia == null) {\n      throw new Error('thermal requires outer diameter');\n    }\n    if (p.innerDia == null) {\n      throw new Error('thermal requires inner diameter');\n    }\n    if (p.gap == null) {\n      throw new Error('thermal requires gap');\n    }\n    maskId = \"thermal-mask-\" + (unique());\n    thx = (p.outerDia - p.innerDia) / 2;\n    outerR = p.outerDia / 2;\n    r = outerR - thx / 2;\n    xMin = p.cx - outerR;\n    xMax = p.cx + outerR;\n    yMin = p.cy - outerR;\n    yMax = p.cy + outerR;\n    halfGap = p.gap / 2;\n    return {\n      shape: [\n        {\n          mask: {\n            id: maskId,\n            _: [\n              {\n                circle: {\n                  cx: p.cx,\n                  cy: p.cy,\n                  r: outerR,\n                  fill: '#fff'\n                }\n              }, {\n                rect: {\n                  x: xMin,\n                  y: -halfGap,\n                  width: p.outerDia,\n                  height: p.gap,\n                  fill: '#000'\n                }\n              }, {\n                rect: {\n                  x: -halfGap,\n                  y: yMin,\n                  width: p.gap,\n                  height: p.outerDia,\n                  fill: '#000'\n                }\n              }\n            ]\n          }\n        }, {\n          circle: {\n            cx: p.cx,\n            cy: p.cy,\n            r: r,\n            fill: 'none',\n            'stroke-width': thx,\n            mask: \"url(#\" + maskId + \")\"\n          }\n        }\n      ],\n      bbox: [xMin, yMin, xMax, yMax]\n    };\n  };\n\n  module.exports = {\n    circle: circle,\n    rect: rect,\n    polygon: polygon,\n    vector: vector,\n    lowerLeftRect: lowerLeftRect,\n    outline: outline,\n    moire: moire,\n    thermal: thermal\n  };\n\n}).call(this);\n\n},{\"./unique-id\":15}],11:[function(require,module,exports){\n(function() {\n  var Parser;\n\n  Parser = (function() {\n    function Parser(formatOpts) {\n      var _ref, _ref1;\n      if (formatOpts == null) {\n        formatOpts = {};\n      }\n      this.format = {\n        zero: (_ref = formatOpts.zero) != null ? _ref : null,\n        places: (_ref1 = formatOpts.places) != null ? _ref1 : null\n      };\n      if (this.format.places != null) {\n        if ((!Array.isArray(this.format.places)) || this.format.places.length !== 2 || typeof this.format.places[0] !== 'number' || typeof this.format.places[1] !== 'number') {\n          throw new Error('parser places format must be an array of two numbers');\n        }\n      }\n      if (this.format.zero != null) {\n        if (typeof this.format.zero !== 'string' || (this.format.zero !== 'L' && this.format.zero !== 'T')) {\n          throw new Error(\"parser zero format must be either 'L' or 'T'\");\n        }\n      }\n    }\n\n    return Parser;\n\n  })();\n\n  module.exports = Parser;\n\n}).call(this);\n\n},{}],12:[function(require,module,exports){\n(function() {\n  var ASSUMED_UNITS, HALF_PI, Macro, Plotter, THREEHALF_PI, TWO_PI, coordFactor, tool, unique;\n\n  unique = require('./unique-id');\n\n  Macro = require('./macro-tool');\n\n  tool = require('./standard-tool');\n\n  coordFactor = require('./svg-coord').factor;\n\n  HALF_PI = Math.PI / 2;\n\n  THREEHALF_PI = 3 * HALF_PI;\n\n  TWO_PI = 2 * Math.PI;\n\n  ASSUMED_UNITS = 'in';\n\n  Plotter = (function() {\n    function Plotter(reader, parser, opts) {\n      var _ref, _ref1;\n      this.reader = reader;\n      this.parser = parser;\n      if (opts == null) {\n        opts = {};\n      }\n      this.units = (_ref = opts.units) != null ? _ref : null;\n      this.notation = (_ref1 = opts.notation) != null ? _ref1 : null;\n      this.macros = {};\n      this.tools = {};\n      this.currentTool = '';\n      this.defs = [];\n      this.group = {\n        g: {\n          _: []\n        }\n      };\n      this.polarity = 'D';\n      this.current = [];\n      this.stepRepeat = {\n        x: 1,\n        y: 1,\n        i: 0,\n        j: 0\n      };\n      this.srOverClear = false;\n      this.srOverCurrent = [];\n      this.mode = null;\n      this.quad = null;\n      this.lastOp = null;\n      this.region = false;\n      this.done = false;\n      this.pos = {\n        x: 0,\n        y: 0\n      };\n      this.path = [];\n      this.attr = {\n        'stroke-linecap': 'round',\n        'stroke-linejoin': 'round',\n        'stroke-width': 0,\n        stroke: '#000'\n      };\n      this.bbox = {\n        xMin: Infinity,\n        yMin: Infinity,\n        xMax: -Infinity,\n        yMax: -Infinity\n      };\n      this.layerBbox = {\n        xMin: Infinity,\n        yMin: Infinity,\n        xMax: -Infinity,\n        yMax: -Infinity\n      };\n    }\n\n    Plotter.prototype.addTool = function(code, params) {\n      var obj, t;\n      if (this.tools[code] != null) {\n        throw new Error(\"cannot reassign tool \" + code);\n      }\n      if (params.macro != null) {\n        t = this.macros[params.macro].run(code, params.mods);\n      } else {\n        t = tool(code, params);\n      }\n      this.tools[code] = {\n        trace: t.trace,\n        pad: (function() {\n          var _i, _len, _ref, _results;\n          _ref = t.pad;\n          _results = [];\n          for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n            obj = _ref[_i];\n            _results.push(obj);\n          }\n          return _results;\n        })(),\n        flash: function(x, y) {\n          return {\n            use: {\n              x: x,\n              y: y,\n              'xlink:href': \"#\" + t.padId\n            }\n          };\n        },\n        bbox: function(x, y) {\n          if (x == null) {\n            x = 0;\n          }\n          if (y == null) {\n            y = 0;\n          }\n          return {\n            xMin: x + t.bbox[0],\n            yMin: y + t.bbox[1],\n            xMax: x + t.bbox[2],\n            yMax: y + t.bbox[3]\n          };\n        }\n      };\n      return this.changeTool(code);\n    };\n\n    Plotter.prototype.changeTool = function(code) {\n      var _ref;\n      this.finishPath();\n      if (this.region) {\n        throw new Error('cannot change tool when in region mode');\n      }\n      if (this.tools[code] == null) {\n        if (!((_ref = this.parser) != null ? _ref.fmat : void 0)) {\n          throw new Error(\"tool \" + code + \" is not defined\");\n        }\n      } else {\n        return this.currentTool = code;\n      }\n    };\n\n    Plotter.prototype.command = function(c) {\n      var code, m, params, state, val, _ref, _ref1;\n      if (c.macro != null) {\n        m = new Macro(c.macro, this.parser.format.places);\n        this.macros[m.name] = m;\n        return;\n      }\n      _ref = c.set;\n      for (state in _ref) {\n        val = _ref[state];\n        if (state === 'region') {\n          this.finishPath();\n        }\n        switch (state) {\n          case 'currentTool':\n            this.changeTool(val);\n            break;\n          case 'units':\n          case 'notation':\n            if (this[state] == null) {\n              this[state] = val;\n            }\n            break;\n          default:\n            this[state] = val;\n        }\n      }\n      if (c.tool != null) {\n        _ref1 = c.tool;\n        for (code in _ref1) {\n          params = _ref1[code];\n          this.addTool(code, params);\n        }\n      }\n      if (c.op != null) {\n        this.operate(c.op);\n      }\n      if (c[\"new\"] != null) {\n        this.finishLayer();\n        if (c[\"new\"].layer != null) {\n          return this.polarity = c[\"new\"].layer;\n        } else if (c[\"new\"].sr != null) {\n          this.finishSR();\n          return this.stepRepeat = c[\"new\"].sr;\n        }\n      }\n    };\n\n    Plotter.prototype.plot = function() {\n      var block, _ref;\n      while (!this.done) {\n        block = this.reader.nextBlock();\n        if (block === false) {\n          if (((_ref = this.parser) != null ? _ref.fmat : void 0) == null) {\n            throw new Error('end of file encountered before required M02 command');\n          } else {\n            throw new Error('end of drill file encountered before M00/M30 command');\n          }\n        } else {\n          this.command(this.parser.parseCommand(block));\n        }\n      }\n      return this.finish();\n    };\n\n    Plotter.prototype.finish = function() {\n      this.finishPath();\n      this.finishLayer();\n      this.finishSR();\n      this.group.g.fill = 'currentColor';\n      this.group.g.stroke = 'currentColor';\n      return this.group.g.transform = \"translate(0,\" + (this.bbox.yMin + this.bbox.yMax) + \") scale(1,-1)\";\n    };\n\n    Plotter.prototype.finishSR = function() {\n      var layer, m, maskId, u, x, y, _i, _j, _k, _len, _ref, _ref1, _ref2, _ref3, _ref4, _ref5;\n      if (this.srOverClear && this.srOverCurrent) {\n        maskId = \"gerber-sr-mask_\" + (unique());\n        m = {\n          mask: {\n            color: '#000',\n            id: maskId,\n            _: []\n          }\n        };\n        m.mask._.push({\n          rect: {\n            fill: '#fff',\n            x: this.bbox.xMin,\n            y: this.bbox.yMin,\n            width: this.bbox.xMax - this.bbox.xMin,\n            height: this.bbox.yMax - this.bbox.yMin\n          }\n        });\n        for (x = _i = 0, _ref = this.stepRepeat.x * this.stepRepeat.i, _ref1 = this.stepRepeat.i; _ref1 > 0 ? _i < _ref : _i > _ref; x = _i += _ref1) {\n          for (y = _j = 0, _ref2 = this.stepRepeat.y * this.stepRepeat.j, _ref3 = this.stepRepeat.j; _ref3 > 0 ? _j < _ref2 : _j > _ref2; y = _j += _ref3) {\n            _ref4 = this.srOverCurrent;\n            for (_k = 0, _len = _ref4.length; _k < _len; _k++) {\n              layer = _ref4[_k];\n              u = {\n                use: {}\n              };\n              if (x !== 0) {\n                u.use.x = x;\n              }\n              if (y !== 0) {\n                u.use.y = y;\n              }\n              u.use['xlink:href'] = '#' + ((_ref5 = layer.C) != null ? _ref5 : layer.D);\n              if (layer.D != null) {\n                u.use.fill = '#fff';\n              }\n              m.mask._.push(u);\n            }\n          }\n        }\n        this.srOverClear = false;\n        this.srOverCurrent = [];\n        this.defs.push(m);\n        return this.group.g.mask = \"url(#\" + maskId + \")\";\n      }\n    };\n\n    Plotter.prototype.finishLayer = function() {\n      var c, h, id, obj, srId, u, w, x, y, _i, _j, _k, _len, _ref, _ref1, _ref2;\n      this.finishPath();\n      if (!this.current.length) {\n        return;\n      }\n      if (this.stepRepeat.x > 1 || this.stepRepeat.y > 1) {\n        srId = \"gerber-sr_\" + (unique());\n        this.current = [\n          {\n            g: {\n              id: srId,\n              _: this.current\n            }\n          }\n        ];\n        if (this.srOverClear || this.stepRepeat.i < this.layerBbox.xMax - this.layerBbox.xMin || this.stepRepeat.j < this.layerBbox.yMax - this.layerBbox.yMin) {\n          obj = {};\n          obj[this.polarity] = srId;\n          this.srOverCurrent.push(obj);\n          if (this.polarity === 'C') {\n            this.srOverClear = true;\n            this.defs.push(this.current[0]);\n          }\n        }\n        for (x = _i = 0, _ref = this.stepRepeat.x; 0 <= _ref ? _i < _ref : _i > _ref; x = 0 <= _ref ? ++_i : --_i) {\n          for (y = _j = 0, _ref1 = this.stepRepeat.y; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; y = 0 <= _ref1 ? ++_j : --_j) {\n            if (!(x === 0 && y === 0)) {\n              u = {\n                use: {\n                  'xlink:href': \"#\" + srId\n                }\n              };\n              if (x !== 0) {\n                u.use.x = x * this.stepRepeat.i;\n              }\n              if (y !== 0) {\n                u.use.y = y * this.stepRepeat.j;\n              }\n              this.current.push(u);\n            }\n          }\n        }\n        this.layerBbox.xMax += (this.stepRepeat.x - 1) * this.stepRepeat.i;\n        this.layerBbox.yMax += (this.stepRepeat.y - 1) * this.stepRepeat.j;\n      }\n      this.addBbox(this.layerBbox, this.bbox);\n      this.layerBbox = {\n        xMin: Infinity,\n        yMin: Infinity,\n        xMax: -Infinity,\n        yMax: -Infinity\n      };\n      if (this.polarity === 'D') {\n        if (this.group.g.mask != null) {\n          this.current.unshift(this.group);\n        }\n        if ((this.group.g.mask == null) && this.group.g._.length) {\n          _ref2 = this.current;\n          for (_k = 0, _len = _ref2.length; _k < _len; _k++) {\n            c = _ref2[_k];\n            this.group.g._.push(c);\n          }\n        } else {\n          this.group = {\n            g: {\n              _: this.current\n            }\n          };\n        }\n      } else if (this.polarity === 'C' && !this.srOverClear) {\n        id = \"gerber-mask_\" + (unique());\n        w = this.bbox.xMax - this.bbox.xMin;\n        h = this.bbox.yMax - this.bbox.yMin;\n        this.current.unshift({\n          rect: {\n            x: this.bbox.xMin,\n            y: this.bbox.yMin,\n            width: w,\n            height: h,\n            fill: '#fff'\n          }\n        });\n        this.defs.push({\n          mask: {\n            id: id,\n            color: '#000',\n            _: this.current\n          }\n        });\n        this.group.g.mask = \"url(#\" + id + \")\";\n      }\n      return this.current = [];\n    };\n\n    Plotter.prototype.finishPath = function() {\n      var key, p, val, _ref;\n      if (this.path.length) {\n        p = {\n          path: {}\n        };\n        if (this.region) {\n          this.path.push('Z');\n        } else {\n          _ref = this.tools[this.currentTool].trace;\n          for (key in _ref) {\n            val = _ref[key];\n            p.path[key] = val;\n          }\n        }\n        p.path.d = this.path;\n        this.current.push(p);\n        return this.path = [];\n      }\n    };\n\n    Plotter.prototype.operate = function(op) {\n      var bbox, ex, ey, shape, sx, sy, t, _i, _len, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7;\n      if (op[\"do\"] === 'last') {\n        op[\"do\"] = this.lastOp;\n        console.warn('modal operation codes are deprecated');\n      } else {\n        this.lastOp = op[\"do\"];\n      }\n      sx = this.pos.x;\n      sy = this.pos.y;\n      if (this.notation === 'I') {\n        this.pos.x += (_ref = op.x) != null ? _ref : 0;\n        this.pos.y += (_ref1 = op.y) != null ? _ref1 : 0;\n      } else {\n        this.pos.x = (_ref2 = op.x) != null ? _ref2 : this.pos.x;\n        this.pos.y = (_ref3 = op.y) != null ? _ref3 : this.pos.y;\n      }\n      ex = this.pos.x;\n      ey = this.pos.y;\n      t = this.tools[this.currentTool];\n      if (this.units == null) {\n        if (this.backupUnits != null) {\n          this.units = this.backupUnits;\n          console.warn(\"units set to '\" + this.units + \"' according to deprecated command G7\" + (this.units === 'in' ? 0 : 1));\n        } else {\n          this.units = ASSUMED_UNITS;\n          console.warn('no units set; assuming inches');\n        }\n      }\n      if (this.notation == null) {\n        if (((_ref4 = this.parser) != null ? _ref4.fmat : void 0) != null) {\n          this.notation = 'A';\n        } else {\n          throw new Error('format has not been set');\n        }\n      }\n      if (op[\"do\"] === 'move' && this.path.length) {\n        return this.path.push('M', ex, ey);\n      } else if (op[\"do\"] === 'flash') {\n        this.finishPath();\n        if (this.region) {\n          throw new Error('cannot flash while in region mode');\n        }\n        if (t.pad) {\n          _ref5 = t.pad;\n          for (_i = 0, _len = _ref5.length; _i < _len; _i++) {\n            shape = _ref5[_i];\n            this.defs.push(shape);\n          }\n          t.pad = false;\n        }\n        this.current.push(t.flash(ex, ey));\n        return this.addBbox(t.bbox(ex, ey), this.layerBbox);\n      } else if (op[\"do\"] === 'int') {\n        if (!this.region && !t.trace) {\n          throw new Error(\"\" + this.currentTool + \" is not a strokable tool\");\n        }\n        if (this.path.length === 0) {\n          this.path.push('M', sx, sy);\n          bbox = !this.region ? t.bbox(sx, sy) : {\n            xMin: sx,\n            yMin: sy,\n            xMax: sx,\n            yMax: sy\n          };\n          this.addBbox(bbox, this.layerBbox);\n        }\n        if (this.mode == null) {\n          this.mode = 'i';\n          console.warn('no interpolation mode set. Assuming linear (G01)');\n        }\n        if (this.mode === 'i') {\n          return this.drawLine(sx, sy, ex, ey);\n        } else {\n          return this.drawArc(sx, sy, ex, ey, (_ref6 = op.i) != null ? _ref6 : 0, (_ref7 = op.j) != null ? _ref7 : 0);\n        }\n      }\n    };\n\n    Plotter.prototype.drawLine = function(sx, sy, ex, ey) {\n      var bbox, exm, exp, eym, eyp, halfHeight, halfWidth, sxm, sxp, sym, syp, t, theta;\n      t = this.tools[this.currentTool];\n      bbox = !this.region ? t.bbox(ex, ey) : {\n        xMin: ex,\n        yMin: ey,\n        xMax: ex,\n        yMax: ey\n      };\n      this.addBbox(bbox, this.layerBbox);\n      if (this.region || t.trace['stroke-width'] >= 0) {\n        return this.path.push('L', ex, ey);\n      } else {\n        halfWidth = t.pad[0].rect.width / 2;\n        halfHeight = t.pad[0].rect.height / 2;\n        sxm = sx - halfWidth;\n        sxp = sx + halfWidth;\n        sym = sy - halfHeight;\n        syp = sy + halfHeight;\n        exm = ex - halfWidth;\n        exp = ex + halfWidth;\n        eym = ey - halfHeight;\n        eyp = ey + halfHeight;\n        theta = Math.atan2(ey - sy, ex - sx);\n        if ((0 <= theta && theta < HALF_PI)) {\n          return this.path.push('M', sxm, sym, sxp, sym, exp, eym, exp, eyp, exm, eyp, sxm, syp, 'Z');\n        } else if ((HALF_PI <= theta && theta < Math.PI)) {\n          return this.path.push('M', sxm, sym, sxp, sym, sxp, syp, exp, eyp, exm, eyp, exm, eym, 'Z');\n        } else if ((-Math.PI <= theta && theta < -HALF_PI)) {\n          return this.path.push('M', sxp, sym, sxp, syp, sxm, syp, exm, eyp, exm, eym, exp, eym, 'Z');\n        } else if ((-HALF_PI <= theta && theta < 0)) {\n          return this.path.push('M', sxm, sym, exm, eym, exp, eym, exp, eyp, sxp, syp, sxm, syp, 'Z');\n        }\n      }\n    };\n\n    Plotter.prototype.drawArc = function(sx, sy, ex, ey, i, j) {\n      var arcEps, c, cand, cen, dist, large, r, rTool, sweep, t, theta, thetaE, thetaS, validCen, xMax, xMin, xn, xp, yMax, yMin, yn, yp, zeroLength, _i, _j, _len, _len1, _ref, _ref1, _ref2;\n      arcEps = 1.5 * coordFactor * Math.pow(10, -1 * ((_ref = (_ref1 = this.parser) != null ? _ref1.format.places[1] : void 0) != null ? _ref : 7));\n      t = this.tools[this.currentTool];\n      if (!this.region && !t.trace['stroke-width']) {\n        throw Error(\"cannot stroke an arc with non-circular tool \" + this.currentTool);\n      }\n      if (this.quad == null) {\n        throw new Error('arc quadrant mode has not been set');\n      }\n      r = Math.sqrt(Math.pow(i, 2) + Math.pow(j, 2));\n      sweep = this.mode === 'cw' ? 0 : 1;\n      large = 0;\n      validCen = [];\n      cand = [[sx + i, sy + j]];\n      if (this.quad === 's') {\n        cand.push([sx - i, sy - j], [sx - i, sy + j], [sx + i, sy - j]);\n      }\n      for (_i = 0, _len = cand.length; _i < _len; _i++) {\n        c = cand[_i];\n        dist = Math.sqrt(Math.pow(c[0] - ex, 2) + Math.pow(c[1] - ey, 2));\n        if ((Math.abs(r - dist)) < arcEps) {\n          validCen.push({\n            x: c[0],\n            y: c[1]\n          });\n        }\n      }\n      thetaE = 0;\n      thetaS = 0;\n      cen = null;\n      for (_j = 0, _len1 = validCen.length; _j < _len1; _j++) {\n        c = validCen[_j];\n        thetaE = Math.atan2(ey - c.y, ex - c.x);\n        if (thetaE < 0) {\n          thetaE += TWO_PI;\n        }\n        thetaS = Math.atan2(sy - c.y, sx - c.x);\n        if (thetaS < 0) {\n          thetaS += TWO_PI;\n        }\n        if (this.mode === 'cw' && thetaS < thetaE) {\n          thetaS += TWO_PI;\n        } else if (this.mode === 'ccw' && thetaE < thetaS) {\n          thetaE += TWO_PI;\n        }\n        theta = Math.abs(thetaE - thetaS);\n        if (this.quad === 's' && theta <= HALF_PI) {\n          cen = c;\n        } else if (this.quad === 'm') {\n          if (theta >= Math.PI) {\n            large = 1;\n          }\n          cen = {\n            x: c.x,\n            y: c.y\n          };\n        }\n        if (cen != null) {\n          break;\n        }\n      }\n      if (cen == null) {\n        console.warn(\"start \" + sx + \",\" + sy + \" \" + this.mode + \" to end \" + ex + \",\" + ey + \" with center offset \" + i + \",\" + j + \" is an impossible arc in \" + (this.quad === 's' ? 'single' : 'multi') + \" quadrant mode with epsilon set to \" + arcEps);\n        return;\n      }\n      rTool = this.region ? 0 : t.bbox().xMax;\n      if (this.mode === 'cw') {\n        _ref2 = [thetaS, thetaE], thetaE = _ref2[0], thetaS = _ref2[1];\n      }\n      xp = thetaS > 0 ? TWO_PI : 0;\n      yp = HALF_PI + (thetaS > HALF_PI ? TWO_PI : 0);\n      xn = Math.PI + (thetaS > Math.PI ? TWO_PI : 0);\n      yn = THREEHALF_PI + (thetaS > THREEHALF_PI ? TWO_PI : 0);\n      if ((thetaS <= xn && xn <= thetaE)) {\n        xMin = cen.x - r - rTool;\n      } else {\n        xMin = (Math.min(sx, ex)) - rTool;\n      }\n      if ((thetaS <= xp && xp <= thetaE)) {\n        xMax = cen.x + r + rTool;\n      } else {\n        xMax = (Math.max(sx, ex)) + rTool;\n      }\n      if ((thetaS <= yn && yn <= thetaE)) {\n        yMin = cen.y - r - rTool;\n      } else {\n        yMin = (Math.min(sy, ey)) - rTool;\n      }\n      if ((thetaS <= yp && yp <= thetaE)) {\n        yMax = cen.y + r + rTool;\n      } else {\n        yMax = (Math.max(sy, ey)) + rTool;\n      }\n      zeroLength = (Math.abs(sx - ex) < arcEps) && (Math.abs(sy - ey) < arcEps);\n      if (this.quad === 'm' && zeroLength) {\n        this.path.push('A', r, r, 0, 0, sweep, ex + 2 * i, ey + 2 * j);\n        xMin = cen.x - r - rTool;\n        yMin = cen.y - r - rTool;\n        xMax = cen.x + r + rTool;\n        yMax = cen.y + r + rTool;\n      }\n      this.path.push('A', r, r, 0, large, sweep, ex, ey);\n      if (this.quad === 's' && zeroLength) {\n        this.path.push('Z');\n      }\n      return this.addBbox({\n        xMin: xMin,\n        yMin: yMin,\n        xMax: xMax,\n        yMax: yMax\n      }, this.layerBbox);\n    };\n\n    Plotter.prototype.addBbox = function(bbox, target) {\n      if (bbox.xMin < target.xMin) {\n        target.xMin = bbox.xMin;\n      }\n      if (bbox.yMin < target.yMin) {\n        target.yMin = bbox.yMin;\n      }\n      if (bbox.xMax > target.xMax) {\n        target.xMax = bbox.xMax;\n      }\n      if (bbox.yMax > target.yMax) {\n        return target.yMax = bbox.yMax;\n      }\n    };\n\n    return Plotter;\n\n  })();\n\n  module.exports = Plotter;\n\n}).call(this);\n\n},{\"./macro-tool\":8,\"./standard-tool\":13,\"./svg-coord\":14,\"./unique-id\":15}],13:[function(require,module,exports){\n(function() {\n  var shapes, standardTool, unique;\n\n  unique = require('./unique-id');\n\n  shapes = require('./pad-shapes');\n\n  standardTool = function(tool, p) {\n    var hole, id, mask, maskId, pad, result, shape;\n    result = {\n      pad: [],\n      trace: false\n    };\n    p.cx = 0;\n    p.cy = 0;\n    id = \"tool-\" + tool + \"-pad-\" + (unique());\n    shape = '';\n    if ((p.dia != null) && (p.verticies == null)) {\n      if ((p.obround != null) || (p.width != null) || (p.height != null) || (p.degrees != null)) {\n        throw new Error(\"incompatible parameters for tool \" + tool);\n      }\n      if (p.dia < 0) {\n        throw new RangeError(\"\" + tool + \" circle diameter out of range (\" + p.dia + \"<0)\");\n      }\n      shape = 'circle';\n      if (p.hole == null) {\n        result.trace = {\n          'stroke-width': p.dia,\n          fill: 'none'\n        };\n      }\n    } else if ((p.width != null) && (p.height != null)) {\n      if ((p.dia != null) || (p.verticies != null) || (p.degrees != null)) {\n        throw new Error(\"incompatible parameters for tool \" + tool);\n      }\n      if (p.width < 0) {\n        throw new RangeError(\"\" + tool + \" rect width out of range (\" + p.width + \"<0)\");\n      }\n      if (p.height < 0) {\n        throw new RangeError(\"\" + tool + \" rect height out of range (\" + p.height + \"<0)\");\n      }\n      shape = 'rect';\n      if ((p.width === 0 || p.height === 0) && !p.obround) {\n        console.warn(\"zero-size rectangle tools are not allowed; converting \" + tool + \" to a zero-size circle\");\n        shape = 'circle';\n        p.dia = 0;\n      }\n      if (!((p.hole != null) || p.obround)) {\n        result.trace = {};\n      }\n    } else if ((p.dia != null) && (p.verticies != null)) {\n      if ((p.obround != null) || (p.width != null) || (p.height != null)) {\n        throw new Error(\"incompatible parameters for tool \" + tool);\n      }\n      if (p.verticies < 3 || p.verticies > 12) {\n        throw new RangeError(\"\" + tool + \" polygon points out of range (\" + p.verticies + \"<3 or >12)]\");\n      }\n      shape = 'polygon';\n    } else {\n      throw new Error('unidentified standard tool shape');\n    }\n    pad = shapes[shape](p);\n    if (p.hole != null) {\n      hole = null;\n      if ((p.hole.dia != null) && (p.hole.width == null) && (p.hole.height == null)) {\n        if (!(p.hole.dia >= 0)) {\n          throw new RangeError(\"\" + tool + \" hole diameter out of range (\" + p.hole.dia + \"<0)\");\n        }\n        hole = shapes.circle({\n          cx: p.cx,\n          cy: p.cy,\n          dia: p.hole.dia\n        });\n        hole = hole.shape;\n        hole.circle.fill = '#000';\n      } else if ((p.hole.width != null) && (p.hole.height != null)) {\n        if (!(p.hole.width >= 0)) {\n          throw new RangeError(\"\" + tool + \" hole width out of range (\" + p.hole.width + \"<0)\");\n        }\n        if (!(p.hole.height >= 0)) {\n          throw new RangeError(\"\" + tool + \" hole height out of range (\" + p.hole.height + \"<0)\");\n        }\n        hole = shapes.rect({\n          cx: p.cx,\n          cy: p.cy,\n          width: p.hole.width,\n          height: p.hole.height\n        });\n        hole = hole.shape;\n        hole.rect.fill = '#000';\n      } else {\n        throw new Error(\"\" + tool + \" has invalid hole parameters\");\n      }\n      maskId = id + '-mask';\n      mask = {\n        mask: {\n          id: id + '-mask',\n          _: [\n            {\n              rect: {\n                x: pad.bbox[0],\n                y: pad.bbox[1],\n                width: pad.bbox[2] - pad.bbox[0],\n                height: pad.bbox[3] - pad.bbox[1],\n                fill: '#fff'\n              }\n            }, hole\n          ]\n        }\n      };\n      pad.shape[shape].mask = \"url(#\" + maskId + \")\";\n      result.pad.push(mask);\n    }\n    if (id) {\n      pad.shape[shape].id = id;\n    }\n    result.pad.push(pad.shape);\n    result.bbox = pad.bbox;\n    result.padId = id;\n    return result;\n  };\n\n  module.exports = standardTool;\n\n}).call(this);\n\n},{\"./pad-shapes\":10,\"./unique-id\":15}],14:[function(require,module,exports){\n(function() {\n  var SVG_COORD_E, getSvgCoord,\n    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };\n\n  SVG_COORD_E = 3;\n\n  getSvgCoord = function(numberString, format) {\n    var after, before, c, i, sign, subNumbers, _i, _j, _len, _len1, _ref, _ref1, _ref2, _ref3;\n    if (numberString != null) {\n      numberString = \"\" + numberString;\n    } else {\n      return NaN;\n    }\n    before = '';\n    after = '';\n    sign = '+';\n    if (numberString[0] === '-' || numberString[0] === '+') {\n      sign = numberString[0];\n      numberString = numberString.slice(1);\n    }\n    if ((__indexOf.call(numberString, '.') >= 0) || (format.zero == null)) {\n      subNumbers = numberString.split('.');\n      if (subNumbers.length > 2) {\n        return NaN;\n      }\n      _ref1 = [subNumbers[0], (_ref = subNumbers[1]) != null ? _ref : ''], before = _ref1[0], after = _ref1[1];\n    } else {\n      if (typeof (format != null ? (_ref2 = format.places) != null ? _ref2[0] : void 0 : void 0) !== 'number' || typeof (format != null ? (_ref3 = format.places) != null ? _ref3[1] : void 0 : void 0) !== 'number') {\n        return NaN;\n      }\n      if (format.zero === 'T') {\n        for (i = _i = 0, _len = numberString.length; _i < _len; i = ++_i) {\n          c = numberString[i];\n          if (i < format.places[0]) {\n            before += c;\n          } else {\n            after += c;\n          }\n        }\n        while (before.length < format.places[0]) {\n          before += '0';\n        }\n      } else if (format.zero === 'L') {\n        for (i = _j = 0, _len1 = numberString.length; _j < _len1; i = ++_j) {\n          c = numberString[i];\n          if (numberString.length - i <= format.places[1]) {\n            after += c;\n          } else {\n            before += c;\n          }\n        }\n        while (after.length < format.places[1]) {\n          after = '0' + after;\n        }\n      }\n    }\n    while (after.length < SVG_COORD_E) {\n      after += '0';\n    }\n    before = before + after.slice(0, SVG_COORD_E);\n    after = after.length > SVG_COORD_E ? \".\" + after.slice(SVG_COORD_E) : '';\n    return Number(sign + before + after);\n  };\n\n  module.exports = {\n    get: getSvgCoord,\n    factor: Math.pow(10, SVG_COORD_E)\n  };\n\n}).call(this);\n\n},{}],15:[function(require,module,exports){\n(function() {\n  var generateUniqueId, id;\n\n  id = 1000;\n\n  generateUniqueId = function() {\n    return id++;\n  };\n\n  module.exports = generateUniqueId;\n\n}).call(this);\n\n},{}],16:[function(require,module,exports){\nvar convertGerber, gerberToSvg;\n\ngerberToSvg = require('gerber-to-svg');\n\nconvertGerber = function(filename, gerber) {\n  var e, e2, obj, string, warnings;\n  warnings = [];\n  if (typeof gerber === 'object') {\n    obj = gerber;\n  } else {\n    try {\n      obj = gerberToSvg(gerber, {\n        object: true,\n        warnArr: warnings\n      });\n    } catch (_error) {\n      e = _error;\n      try {\n        warnings = [];\n        obj = gerberToSvg(gerber, {\n          drill: true,\n          object: true,\n          warnArr: warnings\n        });\n      } catch (_error) {\n        e2 = _error;\n        warnings = [];\n        obj = {};\n      }\n    }\n  }\n  if (obj.svg != null) {\n    string = gerberToSvg(obj);\n  } else {\n    string = '';\n  }\n  return {\n    filename: filename,\n    svgObj: obj,\n    svgString: string,\n    warnings: warnings\n  };\n};\n\nself.addEventListener('message', function(e) {\n  var filename, gerber;\n  gerber = e.data.gerber;\n  filename = e.data.filename;\n  return self.postMessage(convertGerber(filename, gerber));\n}, false);\n\n\n\n},{\"gerber-to-svg\":6}]},{},[16])"],{type:"text/javascript"}))),e=new Worker(window.URL.createObjectURL(new Blob(["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error(\"Cannot find module '\"+o+\"'\")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n;(function () {\n\n  var object = typeof exports != 'undefined' ? exports : this; // #8: web workers\n  var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n\n  function InvalidCharacterError(message) {\n    this.message = message;\n  }\n  InvalidCharacterError.prototype = new Error;\n  InvalidCharacterError.prototype.name = 'InvalidCharacterError';\n\n  // encoder\n  // [https://gist.github.com/999166] by [https://github.com/nignag]\n  object.btoa || (\n  object.btoa = function (input) {\n    var str = String(input);\n    for (\n      // initialize result and counter\n      var block, charCode, idx = 0, map = chars, output = '';\n      // if the next str index does not exist:\n      //   change the mapping table to \"=\"\n      //   check if d has no fractional digits\n      str.charAt(idx | 0) || (map = '=', idx % 1);\n      // \"8 - idx % 1 * 8\" generates the sequence 2, 4, 6, 8\n      output += map.charAt(63 & block >> 8 - idx % 1 * 8)\n    ) {\n      charCode = str.charCodeAt(idx += 3/4);\n      if (charCode > 0xFF) {\n        throw new InvalidCharacterError(\"'btoa' failed: The string to be encoded contains characters outside of the Latin1 range.\");\n      }\n      block = block << 8 | charCode;\n    }\n    return output;\n  });\n\n  // decoder\n  // [https://gist.github.com/1020396] by [https://github.com/atk]\n  object.atob || (\n  object.atob = function (input) {\n    var str = String(input).replace(/=+$/, '');\n    if (str.length % 4 == 1) {\n      throw new InvalidCharacterError(\"'atob' failed: The string to be decoded is not correctly encoded.\");\n    }\n    for (\n      // initialize result and counters\n      var bc = 0, bs, buffer, idx = 0, output = '';\n      // get next character\n      buffer = str.charAt(idx++);\n      // character found in table? initialize bit storage and add its ascii value;\n      ~buffer && (bs = bc % 4 ? bs * 64 + buffer : buffer,\n        // and if not first of each 4 characters,\n        // convert the first 8 bits to one ascii character\n        bc++ % 4) ? output += String.fromCharCode(255 & bs >> (-2 * bc & 6)) : 0\n    ) {\n      // try to find character in table (0-63, not found => -1)\n      buffer = chars.indexOf(buffer);\n    }\n    return output;\n  });\n\n}());\n\n},{}],2:[function(require,module,exports){\nvar Base64;\n\nBase64 = require('Base64');\n\nif (typeof self.btoa !== 'function') {\n  self.btoa = Base64.btoa;\n}\n\nself.addEventListener('message', function(e) {\n  var name, string;\n  string = e.data.string;\n  name = e.data.name;\n  return self.postMessage({\n    name: name,\n    string: btoa(string)\n  });\n});\n\n\n\n},{\"Base64\":1}]},{},[2])"],{type:"text/javascript"}))),c=function(a){function b(){return b.__super__.constructor.apply(this,arguments)
}return g(b,a),b.prototype.initialize=function(){return this.attachConverterHandler(),this.attachEncoderHandler(),this.on("change:svg change:style",this.encode)},b.prototype.encode=function(a){var b,c,d;return a.set("svg64",!1),c=a.get("svg"),d=a.get("style"),c?(null!=d&&(b=c.match(/^.*?>/)[0].length,c=c.slice(0,b)+d+c.slice(b)),e.postMessage({name:a.get("name"),string:c})):void 0},b.prototype.convert=function(a,b){return d.postMessage({filename:a,gerber:b})},b.prototype.attachEncoderHandler=function(){var a,b;return b=this,a=function(a){var c;return(c=b.findWhere({name:a.data.name}))?c.set("svg64",a.data.string):void 0},e.addEventListener("message",a,!1)},b.prototype.attachConverterHandler=function(){var a,b;return b=this,a=function(a){var c;return(c=b.findWhere({name:a.data.filename}))?(c.set("svgObj",a.data.svgObj),c.set("svg",a.data.svgString),c.set("warnings",a.data.warnings),c.trigger("processEnd",c)):void 0},d.addEventListener("message",a,!1)},b}(Backbone.Collection),b.exports=c},{}],"/Users/mc/projects/svgerber/src/color-options.coffee":[function(a,b){b.exports={cf:{bare:{bg:"#C87533",txt:"white"},gold:{bg:"goldenrod",txt:"white"},"Ni/Au":{bg:"whitesmoke",txt:"black"},hasl:{bg:"silver",txt:"black"}},sm:{red:{bg:"darkred",txt:"white"},orange:{bg:"darkorange",txt:"black"},yellow:{bg:"#FFFF66",txt:"black"},green:{bg:"darkgreen",txt:"white"},blue:{bg:"navy",txt:"white"},purple:{bg:"indigo",txt:"white"},black:{bg:"black",txt:"white"},white:{bg:"white",txt:"black"}},ss:{red:{bg:"red",txt:"white"},yellow:{bg:"yellow",txt:"black"},green:{bg:"green",txt:"white"},blue:{bg:"blue",txt:"white"},black:{bg:"black",txt:"white"},white:{bg:"white",txt:"black"}}}},{}],"/Users/mc/projects/svgerber/src/github-api-url.coffee":[function(a,b){b.exports=function(a){var b,c,d,e,f,g;return a=null!=(g=a.match(/github\.com\S+/))?g[0].split("/"):void 0,(null!=a?a.length:void 0)?(b="https://api.github.com/repos",d=a[1],f=a[2],c=a[4],e=a.slice(5).join("/"),a=""+b+"/"+d+"/"+f+"/contents/"+e+"?ref="+c):!1}},{}],"/Users/mc/projects/svgerber/src/identify-layer.coffee":[function(a,b){var c,d,e,f,g,h;c=a("./layer-options"),h=/top/i,d=/bottom/i,g=/(silk)|(ss)/i,e=/(soldermask)|(sm)/i,f=/(paste)|(sp)|(pm)/i,b.exports=function(a){var b,i,j,k,l,m,n,o,p;for(j="",k=0,l=c.length;l>k;k++)if(i=c[k],i.match.test(a))return i.val;return a=a.split(".")[0],(b=null!=(m=a.match(h))&&null!=(n=m[0])?n.length:void 0)?j="t":(b=null!=(o=a.match(d))&&null!=(p=o[0])?p.length:void 0)&&(j="b"),g.test(a)?j+="ss":e.test(a)?j+="sm":f.test(a)?j+="sp":a.length===b&&(j+="cu"),_.find(c,{val:j})||(j="drw"),j}},{"./layer-options":"/Users/mc/projects/svgerber/src/layer-options.coffee"}],"/Users/mc/projects/svgerber/src/layer-options.coffee":[function(a,b){b.exports=[{val:"tcu",desc:"top copper",match:/\.(gtl)|(cmp)$/i,side:"top",mult:!1},{val:"tsm",desc:"top soldermask",match:/\.(gts)|(stc)$/i,side:"top",mult:!1},{val:"tss",desc:"top silkscreen",match:/\.(gto)|(plc)$/i,side:"top",mult:!1},{val:"tsp",desc:"top solderpaste",match:/\.(gtp)|(crc)$/i,side:"top",mult:!1},{val:"bcu",desc:"bottom copper",match:/\.(gbl)|(sol)$/i,side:"bottom",mult:!1},{val:"bsm",desc:"bottom soldermask",match:/\.(gbs)|(sts)$/i,side:"bottom",mult:!1},{val:"bss",desc:"bottom silkscreen",match:/\.(gbo)|(pls)$/i,side:"bottom",mult:!1},{val:"bsp",desc:"bottom solderpaste",match:/\.(gbp)|(crs)$/i,side:"bottom",mult:!1},{val:"icu",desc:"inner copper",match:/\.(gp\d+)|(g\d+l)$/i,side:"none",mult:!0},{val:"out",desc:"board outline",match:/(\.(gko)|(mil)$)|edge/i,side:"both",mult:!1},{val:"drw",desc:"gerber drawing",match:/\.gbr$/i,side:"none",mult:!0},{val:"drl",desc:"drill hits",match:/(\.xln$)|(\.drl$)|(\.txt$)|(\.drd$)/i,side:"both",mult:!0}]},{}],"/Users/mc/projects/svgerber/src/models/board.coffee":[function(a,b){var c,d,e,f,g={}.hasOwnProperty,h=function(a,b){function c(){this.constructor=a}for(var d in b)g.call(b,d)&&(a[d]=b[d]);return c.prototype=b.prototype,a.prototype=new c,a.__super__=b.prototype,a};e=a("./render"),d=a("../collections/layers"),f=a("../layer-options"),c=function(a){function b(){return b.__super__.constructor.apply(this,arguments)}return h(b,a),b.prototype.defaults=_.extend({boardLayers:{},style:'<style type="text/css"> .Board--board { color: dimgrey; } .Board--cu { color: lightgrey; } .Board--cf { color: goldenrod; } .Board--sm { color: darkgreen; opacity: 0.75; } .Board--ss { color: white; } .Board--sp { color: silver; } .Board--out { color: black; } </style>'},e.prototype.defaults),b.prototype.initialize=function(){var a;return a=this.get("layers"),this.listenTo(a,"change:type change:svg change:gerber remove",_.debounce(this.handleLayersChange,10))},b.prototype.getBoardLayers=function(){var a,b;return b=this.get("name"),a=this.get("layers").filter(function(a){var c;return c=_.find(f,{val:a.get("type")}),(null!=c?c.side:void 0)===b||"both"===(null!=c?c.side:void 0)}),this.set("boardLayers",_.map(a,function(a){return{type:a.get("type"),svgObj:a.get("svgObj")}})),this.trigger("buildNeeded",this)},b.prototype.handleLayersChange=function(){var a,b,c;return a=this.get("layers"),a.validateLayers()&&(b=null!=(c=a.filter(function(a){return null!=a.get("svgObj")}))?c:[],a.length===b.length)?this.getBoardLayers():void 0},b}(e),b.exports=c},{"../collections/layers":"/Users/mc/projects/svgerber/src/collections/layers.coffee","../layer-options":"/Users/mc/projects/svgerber/src/layer-options.coffee","./render":"/Users/mc/projects/svgerber/src/models/render.coffee"}],"/Users/mc/projects/svgerber/src/models/layer.coffee":[function(a,b){var c,d,e,f,g={}.hasOwnProperty,h=function(a,b){function c(){this.constructor=a}for(var d in b)g.call(b,d)&&(a[d]=b[d]);return c.prototype=b.prototype,a.prototype=new c,a.__super__=b.prototype,a};d=a("./render"),f=a("../layer-options"),e=a("../identify-layer"),c=function(a){function b(){return b.__super__.constructor.apply(this,arguments)}return h(b,a),b.prototype.defaults=_.extend({gerber:"",type:"drw",svgObj:null},d.prototype.defaults),b.prototype.initialize=function(){return this.once("change:svgObj",function(){return this.unset("gerber"),this.setLayerType()}),this.once("change:warnings",function(){var a,b,c,d,e;for(a={},e=this.get("warnings"),c=0,d=e.length;d>c;c++)b=e[c],a[b]=null!=a[b]?a[b]+1:1;return this.set("warnings",_.map(a,function(a,b){return b+(a>1?" - x"+a:"")})),this.trigger("warningsConsolidated")})},b.prototype.setLayerType=function(){return this.set("type",Object.keys(this.get("svgObj")).length?e(this.get("name")):"oth")},b.prototype.validate=function(a){var b;return"oth"===a.type||_.find(f,{val:a.type}).mult||(b=this.collection.where({type:a.type}),1===b.length)?null:"duplicate layer selection"},b}(d),b.exports=c},{"../identify-layer":"/Users/mc/projects/svgerber/src/identify-layer.coffee","../layer-options":"/Users/mc/projects/svgerber/src/layer-options.coffee","./render":"/Users/mc/projects/svgerber/src/models/render.coffee"}],"/Users/mc/projects/svgerber/src/models/render.coffee":[function(a,b){var c,d={}.hasOwnProperty,e=function(a,b){function c(){this.constructor=a}for(var e in b)d.call(b,e)&&(a[e]=b[e]);return c.prototype=b.prototype,a.prototype=new c,a.__super__=b.prototype,a};c=function(a){function b(){return b.__super__.constructor.apply(this,arguments)}return e(b,a),b.prototype.defaults={name:"",svg:"",svgObj:null,svg64:!1,warnings:[]},b}(Backbone.Model),b.exports=c},{}],"/Users/mc/projects/svgerber/src/routers/router.coffee":[function(a,b){var c;c=$("#main-nav").height(),b.exports=Backbone.Router.extend({initialize:function(){return this.route(/.*/,this.scroll)},scroll:function(){var a,b;return b=Backbone.history.fragment,a="."+b+"-anchor",$("html, body").animate({scrollTop:b?$(a).offset().top-1.15*c:0},300)}})},{}],"/Users/mc/projects/svgerber/src/views/app-view.coffee":[function(a,b){var c,d,e,f,g,h,i,j,k,l,m,n;l=a("../github-api-url"),f=a("./filelist-item"),h=a("./layer-view"),d=a("./board-view"),e=a("./color-picker"),i=a("./modal-view"),j=a("./unsupported-view"),g=a("../collections/layers"),m=new g,c=a("../collections/boards"),k=new c,k.add([{name:"top",layers:m},{name:"bottom",layers:m}]),n=new i,b.exports=Backbone.View.extend({el:"#svgerber-app",events:{"drop #dropzone":"handleFileSelect","dragover #dropzone":function(a){return a.preventDefault(),a.stopPropagation(),a.originalEvent.dataTransfer.dropEffect="copy"},"change #upload-select":"handleFileSelect","click #sample-btn":"loadSamples","click #url-paste-btn":"showPaste","click #url-submit-btn":"processUrls","click #url-cancel-btn":"hidePaste"},initialize:function(){return this.listenTo(m,"add",this.addFilelistItem),this.listenTo(m,"processEnd",this.addBoardLayer),this.listenTo(k,"change:svg",this.addBoardRender),this.listenTo(k,"change:svg",this.handleColorPicker),this.listenTo(m,"add remove",this.handleNavIcons),this.$el.append(n.render().el),this.listenTo(m,"openModal",this.handleOpenModal),this.listenTo(k,"openModal",this.handleOpenModal)},restart:function(){return m.remove(m.models)},addFilelistItem:function(a){var b;return b=new f({model:a}),$("#filelist").append(b.render().el)},addBoardLayer:function(a){var b;return a.get("svg").length?(b=new h({model:a}),$("#layer-output").append(b.render().el)):void 0},addBoardRender:function(a){var b,c;return b=$("#board-output").find(".LayerHeading").text(),a.get("svg").length&&null==b.match(a.get("name"))?(c=new d({model:a}),$("#board-output").append(c.render().el)):void 0},handleOpenModal:function(a){return n.openModal(a)},handleColorPicker:function(a){var b,c,d;return c=$("#board-output").siblings(".ColorPicker").length,b=$("#board-output").children().length,!c&&b?(d=new e({collection:a}),$("#board-output").after(d.render().el)):void 0},handleFileSelect:function(a){var b,c,d,e,f,g,h;for(a.preventDefault(),a.stopPropagation(),c=null!=(g=a.originalEvent)&&null!=(h=g.dataTransfer)?h.files:void 0,null==c&&(c=a.target.files),d=function(a){var b;return m.add({name:a.name},{validate:!0}),b=new FileReader,b.onloadend=function(b){return b.stopPropagation(),b.preventDefault(),b.target.readyState===FileReader.DONE?m.findWhere({name:a.name}).set("gerber",b.target.result):void 0},b.readAsText(a)},e=0,f=c.length;f>e;e++)b=c[e],d(b);return!1},loadSamples:function(){var a,b,c,d,e;for(b=["clockblock-hub-B_Cu.gbl","clockblock-hub-B_Mask.gbs","clockblock-hub-B_SilkS.gbo","clockblock-hub-Edge_Cuts.gbr","clockblock-hub-F_Cu.gtl","clockblock-hub-F_Mask.gts","clockblock-hub-F_Paste.gtp","clockblock-hub-F_SilkS.gto","clockblock-hub-NPTH.drl","clockblock-hub.drl"],this.restart(),e=[],c=0,d=b.length;d>c;c++)a=b[c],e.push(function(a){return m.add({name:a},{validate:!0}),$.ajax({type:"GET",url:"./"+a,dataType:"text",success:function(b){return m.findWhere({name:a}).set("gerber",b)}})}(a));return e},showPaste:function(){return $("#url-paste-form").removeClass("is-hidden")},hidePaste:function(){return $("#url-paste").val(""),$("#url-paste-form").addClass("is-hidden")},processUrls:function(){var a,b,c,d;for(b=$("#url-paste").val().split("\n"),c=0,d=b.length;d>c;c++)a=b[c],a=l(a),a&&$.ajax({type:"GET",url:a,contentType:"application/vnd.github.VERSION.raw",dataType:"json",success:function(a){return m.add({name:a.name},{validate:!0}),m.findWhere({name:a.name}).set("gerber",a.content)}});return this.hidePaste()},handleNavIcons:function(){return 0===m.length?($("#nav-filelist, #nav-output, #nav-layers").addClass("is-disabled"),this.changeIcon($(".Nav--brand"),"octicon-jump-up"),$("#nav-top").off("click",this.restart)):($("#nav-filelist, #nav-output, #nav-layers").removeClass("is-disabled"),this.changeIcon($(".Nav--brand"),"octicon-sync"),$("#nav-top").on("click",this.restart))},changeIcon:function(a,b){return a.removeClass(function(a,b){var c;return null!=(c=b.match(/octicon-\S+/g))?c.join(" "):void 0}).addClass(b)}})},{"../collections/boards":"/Users/mc/projects/svgerber/src/collections/boards.coffee","../collections/layers":"/Users/mc/projects/svgerber/src/collections/layers.coffee","../github-api-url":"/Users/mc/projects/svgerber/src/github-api-url.coffee","./board-view":"/Users/mc/projects/svgerber/src/views/board-view.coffee","./color-picker":"/Users/mc/projects/svgerber/src/views/color-picker.coffee","./filelist-item":"/Users/mc/projects/svgerber/src/views/filelist-item.coffee","./layer-view":"/Users/mc/projects/svgerber/src/views/layer-view.coffee","./modal-view":"/Users/mc/projects/svgerber/src/views/modal-view.coffee","./unsupported-view":"/Users/mc/projects/svgerber/src/views/unsupported-view.coffee"}],"/Users/mc/projects/svgerber/src/views/board-view.coffee":[function(a,b){var c,d,e={}.hasOwnProperty,f=function(a,b){function c(){this.constructor=a}for(var d in b)e.call(b,d)&&(a[d]=b[d]);return c.prototype=b.prototype,a.prototype=new c,a.__super__=b.prototype,a};d=a("./render-view"),c=function(a){function b(){return b.__super__.constructor.apply(this,arguments)}return f(b,a),b.prototype.className="BoardContainer",b.prototype.initialize=function(){return b.__super__.initialize.call(this),this.listenTo(this.model,"change:svg change:style",this.render)},b.prototype.render=function(){var a;return b.__super__.render.call(this),a=this.model.get("svg"),this.$(".LayerTitle").html("board "+this.model.get("name")),this.$("svg").prepend(this.model.get("style")),a.length?this:(this.model.trigger("renderRemove"),this.remove())},b}(d),b.exports=c},{"./render-view":"/Users/mc/projects/svgerber/src/views/render-view.coffee"}],"/Users/mc/projects/svgerber/src/views/color-picker.coffee":[function(a,b){var c;c=a("../color-options"),b.exports=Backbone.View.extend({tagName:"div",className:"ColorPicker",template:_.template($("#color-picker-template").html()),events:{"click .ColorPicker--btn":"handleColorChange","click #show-color-picker-btn":"toggleColorPicker"},initialize:function(){return this.listenTo(this.collection.collection,"renderRemove",this.handleBoardRemoval)},render:function(){return this.$el.html(this.template({cfColors:c.cf,smColors:c.sm,ssColors:c.ss})),this.$el.find(".ColorPicker--box").addClass("is-retracted"),this.$el.find(".ColorPicker--btn").each(function(){var a,b,d,e;return a=$(this),d=a.parent().attr("id").slice(6,8),e=a.html(),b=c[d][e],a.css("background-color",b.bg).css("color",b.txt)}),this.getCurrentColors(),this},getCurrentColors:function(){var a,b,d,e,f,g,h,i,j,k,l,m;for(a=this.collection.collection.pluck("style"),i=a[0],l=["cf","sm","ss"],m=[],j=0,k=l.length;k>j;j++)d=l[j],h=new RegExp(".Board--"+d+" { color: .*?;"),e=i.match(h),b=e[0].slice(20,-1),g=c[d],f=_.findKey(g,_.find(g,function(a){return a.bg===b})),m.push(this.$el.find("#board-"+d+"-color-buttons").children().each(function(){var a;return(a=$(this)).html()===f?a.prop("disabled",!0):void 0}));return m},handleColorChange:function(a){var b;return b=$(a.currentTarget),b.prop("disabled",!0).siblings().prop("disabled",!1),_.delay(function(a){var d,e,f,g,h;switch(e=b.parent().attr("id").slice(6,8),g=b.html(),d=c[e][g].bg,e){case"cf":f=".Board--cf { color: "+d+"; }",h=/\.Board--cf {.*?}/;break;case"sm":f=".Board--sm { color: "+d+"; opacity: 0.75; }",h=/\.Board--sm {.*?}/;break;case"ss":f=".Board--ss { color: "+d+"; }",h=/\.Board--ss {.*?}/}return a.collection.collection.each(function(a){return a.set("style",a.get("style").replace(h,f))})},10,this)},handleBoardRemoval:function(){var a;return a=!1,this.collection.collection.each(function(b){return b.get("svg").length?a=!0:void 0}),a?void 0:this.remove()},toggleColorPicker:function(){var a,b;return b=$(".ColorPicker--box"),a=$("#show-color-picker-btn").children(".octicon"),b.hasClass("is-retracted")?(b.removeClass("is-retracted"),this.changeIcon(a,"octicon-chevron-up")):b.length?(b.addClass("is-retracted"),this.changeIcon(a,"octicon-chevron-down")):void 0},changeIcon:function(a,b){return a.removeClass(function(a,b){var c;return null!=(c=b.match(/octicon-\S+/g))?c.join(" "):void 0}).addClass(b)}})},{"../color-options":"/Users/mc/projects/svgerber/src/color-options.coffee"}],"/Users/mc/projects/svgerber/src/views/filelist-item.coffee":[function(a,b){var c;c=a("../layer-options"),b.exports=Backbone.View.extend({tagName:"li",className:"UploadList--item",template:_.template($("#filelist-item-template").html()),events:{"click .UploadList--itemDelete":"removeLayer","change .UploadList--SelectMenu":"changeLayerType","click .UploadList--SelectMenu":function(a){return a.stopPropagation()},click:"showWarnings"},initialize:function(){return this.listenTo(this.model,"remove",this.remove),this.listenTo(this.model,"change:type",this.renderType),this.listenTo(this.model,"valid invalid",this.renderValidation),this.listenToOnce(this.model,"processEnd",this.renderProcessing),this.listenToOnce(this.model,"warningsConsolidated",this.renderWarnings)},renderValidation:function(){var a;return a=this.$el.find(".UploadList--selectIcon"),this.model.validationError?(this.$el.removeClass("is-valid").addClass("is-invalid"),this.changeIcon(a,"octicon-circle-slash")):(this.$el.removeClass("is-invalid").addClass("is-valid"),this.changeIcon(a,"octicon-chevron-right"))},renderProcessing:function(){return null==this.model.get("svgObj")?this.$el.addClass("is-processing"):(this.$el.removeClass("is-processing"),this.model.get("svg")?void 0:(this.$el.addClass("is-unprocessable"),this.$el.find(".UploadList--text").html("did not process"),this.$el.find("select.UploadList--SelectMenu").remove()))},renderWarnings:function(){var a,b,c;return c=this.model.get("warnings"),c.length?(this.$el.addClass("is-warned"),a=this.$(".UploadList--itemWarnings"),a.html(function(){var a,d,e;for(e=[],a=0,d=c.length;d>a;a++)b=c[a],e.push("<li>"+b+"</li>");return e}()),this.$(".UploadList--warningIcon").removeClass("is-hidden")):void 0},showWarnings:function(){return this.model.get("warnings").length?this.$(".UploadList--itemWarningsContainer").toggleClass("is-retracted"):void 0},render:function(){return this.$el.html(this.template({filename:this.model.get("name"),type:this.model.get("type"),options:c})),this.renderType(),this.renderValidation(),this.renderProcessing(),this},renderType:function(){return this.$el.find("option[value='"+this.model.get("type")+"']").prop("selected",!0)},removeLayer:function(){var a;return this.undelegateEvents(),a=this.model,this.$el.animate({height:0},{duration:100,queue:!1,easing:"linear",complete:function(){return a.collection.remove(a)}})},changeLayerType:function(){return this.model.set("type",this.$el.find("option:selected").attr("value"))},changeIcon:function(a,b){return a.removeClass(function(a,b){var c;return null!=(c=b.match(/octicon-\S+/g))?c.join(" "):void 0}).addClass(b)}})},{"../layer-options":"/Users/mc/projects/svgerber/src/layer-options.coffee"}],"/Users/mc/projects/svgerber/src/views/layer-view.coffee":[function(a,b){var c,d,e,f={}.hasOwnProperty,g=function(a,b){function c(){this.constructor=a}for(var d in b)f.call(b,d)&&(a[d]=b[d]);return c.prototype=b.prototype,a.prototype=new c,a.__super__=b.prototype,a};d=a("./render-view"),e=a("../layer-options"),c=function(a){function b(){return b.__super__.constructor.apply(this,arguments)}return g(b,a),b.prototype.className="LayerContainer",b.prototype.initialize=function(){return b.__super__.initialize.call(this),this.listenTo(this.model,"change:type",this.renderTitle)},b.prototype.renderTitle=function(){return this.$(".LayerTitle").html(_.find(e,{val:this.model.get("type")}).desc)},b.prototype.render=function(){return b.__super__.render.call(this),this.renderTitle(),this},b}(d),b.exports=c},{"../layer-options":"/Users/mc/projects/svgerber/src/layer-options.coffee","./render-view":"/Users/mc/projects/svgerber/src/views/render-view.coffee"}],"/Users/mc/projects/svgerber/src/views/modal-view.coffee":[function(a,b){var c,d,e=function(a,b){return function(){return a.apply(b,arguments)}},f={}.hasOwnProperty,g=function(a,b){function c(){this.constructor=a}for(var d in b)f.call(b,d)&&(a[d]=b[d]);return c.prototype=b.prototype,a.prototype=new c,a.__super__=b.prototype,a};d="undefined"!=typeof document.createElement("a").download,c=function(a){function b(){return this.resize=e(this.resize,this),b.__super__.constructor.apply(this,arguments)}return g(b,a),b.prototype.tagName="div",b.prototype.className="Modal",b.prototype.template=_.template($("#modal-template").html()),b.prototype.events={click:"handleClick"},b.prototype.initialize=function(){return this.closeModal()},b.prototype.render=function(a){var b;return b=null!=a?a.get("svg64"):void 0,this.$el.html(this.template({name:null!=a?a.get("name"):void 0,src:null!=b?"data:image/svg+xml;base64,"+b:"",canDownload:d})),this},b.prototype.resize=function(){var a,b,c,d,e;return a=this.$el.height(),e=this.$el.width(),b=this.$(".Modal--img"),c=b.height(),d=b.width(),e/d>a/c?b.height(.9*a):b.width(.9*e)},b.prototype.openModal=function(a){var b;return this.$el.removeClass("is-hidden"),this.render(a),b=this.$(".Modal--img"),null!=a.get("boardLayers")?b.addClass("Modal--dark"):b.removeClass("Modal--dark"),b.one("load",this.resize)},b.prototype.closeModal=function(){return this.$el.addClass("is-hidden")},b.prototype.handleClick=function(){return this.closeModal()},b}(Backbone.View),b.exports=c},{}],"/Users/mc/projects/svgerber/src/views/render-view.coffee":[function(a,b){var c,d,e={}.hasOwnProperty,f=function(a,b){function c(){this.constructor=a}for(var d in b)e.call(b,d)&&(a[d]=b[d]);return c.prototype=b.prototype,a.prototype=new c,a.__super__=b.prototype,a};d="undefined"!=typeof document.createElement("a").download,c=function(a){function b(){return b.__super__.constructor.apply(this,arguments)}return f(b,a),b.prototype.tagName="div",b.prototype.template=_.template($("#board-layer-template").html()),b.prototype.events={"click .Btn--download":"handleDownloadClick","click .LayerDrawing":"handleClick"},b.prototype.initialize=function(){return this.listenTo(this.model,"change:svg64",this.handleDownloadLink),this.listenTo(this.model,"remove",this.remove)},b.prototype.handleDownloadClick=function(a){return d?void 0:(a.preventDefault(),a.stopPropagation(),this.handleClick())},b.prototype.handleClick=function(){return this.model.trigger("openModal",this.model)},b.prototype.render=function(){return this.$el.html(this.template({name:this.model.get("name"),img:this.model.get("svg")})),this.resize(),this},b.prototype.resize=function(){var a,b,c,d;return b=this.$("svg")[0],null!=b?(d=b.width.baseVal.value,c=b.height.baseVal.value,a=c/d,this.$(".LayerDrawing").css("padding-bottom",""+100*a+"%")):void 0},b.prototype.handleDownloadLink=function(){var a,b;return a=this.$(".Btn--download"),b=this.model.get("svg64"),b?(d&&a.attr("href","data:image/svg+xml;base64,"+b),a.removeClass("is-disabled")):a.addClass("is-disabled")},b}(Backbone.View),b.exports=c},{}],"/Users/mc/projects/svgerber/src/views/unsupported-view.coffee":[function(a,b){var c,d,e={}.hasOwnProperty,f=function(a,b){function c(){this.constructor=a}for(var d in b)e.call(b,d)&&(a[d]=b[d]);return c.prototype=b.prototype,a.prototype=new c,a.__super__=b.prototype,a};d="undefined"!=typeof document.createElement("a").download,c=function(a){function b(){return b.__super__.constructor.apply(this,arguments)}return f(b,a),b.prototype.tagName="div",b.prototype.className="Unsupported",b.prototype.template=_.template($("#unsupported-template").html()),b.prototype.events={"click .Unsupported--btn":"tryAnyway"},b.prototype.render=function(){return this.$el.html(this.template()),this},b.prototype.tryAnyway=function(){return this.$el.remove()},b}(Backbone.View),b.exports=c},{}]},{},["./src/index.coffee"]);